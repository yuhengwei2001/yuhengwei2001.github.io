<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VivadoUserGuide</title>
      <link href="//article/"/>
      <url>//article/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="综合-Synthesis"><a href="#综合-Synthesis" class="headerlink" title="综合 (Synthesis)"></a>综合 (Synthesis)</h2><blockquote><p>参考: UG901 Vivado Design Suite User Guide : Synthesis</p></blockquote><h3 id="综合设置"><a href="#综合设置" class="headerlink" title="综合设置"></a>综合设置</h3><h4 id="directive"><a href="#directive" class="headerlink" title="-directive"></a>-directive</h4><ol><li>Default</li></ol><ul><li>功能：使用默认设置。详见表1-2。</li><li>特点：<ul><li>提供一种平衡的优化方案，适合大多数设计需求。</li></ul></li></ul><ol start="2"><li>RuntimeOptimized</li></ol><ul><li>功能：减少时序优化，消除一些RTL优化，以减少综合运行时间。</li><li>特点：<ul><li>优先考虑快速运行时间，可能会牺牲一些设计性能。</li><li>适用于对综合时间要求较高的设计场景。</li></ul></li></ul><ol start="3"><li>AreaOptimized_high</li></ol><ul><li>功能：进行一般面积优化，包括强制三进制加法器实现，应用新的阈值以在比较器中使用进位链，并实现面积优化的多路复用器。</li><li>特点：<ul><li>强调减少设计占用的面积。</li><li>适用于面积受限的设计。</li></ul></li></ul><ol start="4"><li>AreaOptimized_medium</li></ol><ul><li>功能：进行一般面积优化，包括改变控制集优化的阈值，强制三进制加法器实现，降低DSP块推断的乘法器阈值，将移位寄存器移入BRAM，应用较低的阈值以在比较器中使用进位链，以及面积优化的多路复用器操作。</li><li>特点：<ul><li>平衡面积优化和性能需求。</li><li>适用于对面积有要求但不希望显著牺牲性能的设计。</li></ul></li></ul><ol start="5"><li>AlternateRoutability</li></ol><ul><li>功能：一组算法以改善可布线性（减少MUXFs和CARRYs的使用）。</li><li>特点：<ul><li>提高设计的可布线性，减少布线拥堵。</li><li>适用于布线复杂、容易出现拥堵的设计。</li></ul></li></ul><ol start="6"><li>AreaMapLargeShiftRegToBRAM</li></ol><ul><li>功能：检测大的移位寄存器并使用专用块RAM实现。</li><li>特点：<ul><li>减少逻辑单元的使用，节省面积。</li><li>适用于包含大量移位寄存器的设计。</li></ul></li></ul><ol start="7"><li>AreaMultThresholdDSP</li></ol><ul><li>功能：降低专用DSP块推断的阈值。</li><li>特点：<ul><li>提高DSP块的利用率，减少逻辑单元的使用。</li><li>适用于包含大量乘法运算的设计。</li></ul></li></ul><ol start="8"><li>FewerCarryChains</li></ol><ul><li>功能：使用更高的操作数大小阈值，以使用LUT代替进位链。</li><li>特点：<ul><li>减少进位链的使用，优化逻辑单元的分配。</li><li>适用于逻辑密集且希望减少进位链使用的设计。</li></ul></li></ul><ol start="9"><li>LogicCompaction</li></ol><ul><li>功能：以一种使逻辑更紧凑的方式安排进位链和LUT，使用更少的SLICES。</li><li>特点：<ul><li>减少逻辑单元的使用，但可能对时序QoR产生负面影响。</li><li>适用于对面积有严格要求且能够接受时序性能轻微下降的设计。</li></ul></li></ul><ol start="10"><li>PerformanceOptimized</li></ol><ul><li>功能：进行一般时序优化，包括降低逻辑级别，以牺牲面积为代价。</li><li>特点：<ul><li>优化时序性能，适用于时序要求严格的设计。</li></ul></li></ul><ol start="11"><li>PowerOptimized_high</li></ol><ul><li>功能：进行一般时序优化，包括增加逻辑级别，以牺牲面积为代价。</li><li>特点：<ul><li>强调功耗优化，适用于功耗要求高的设计。</li></ul></li></ul><ol start="12"><li>PowerOptimized_medium</li></ol><ul><li>功能：通过降低逻辑级别减少来进行一般时序优化，以牺牲面积为代价。</li><li>特点：<ul><li>平衡时序和功耗优化，适用于希望在功耗和时序之间取得平衡的设计。</li></ul></li></ul><h4 id="flatten-hierarchy"><a href="#flatten-hierarchy" class="headerlink" title="-flatten_hierarchy"></a>-flatten_hierarchy</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用途：</span><br><span class="line">    确定Vivado合成如何控制层次结构。</span><br><span class="line">值:</span><br><span class="line">    -full   :指示工具将层次结构完全平坦化，只留下顶层。</span><br><span class="line">    </span><br><span class="line">    -rebuild:设置后，rebuild允许合成工具平铺层次结构，执行合成，然后基于原始RTL重建层次结构。</span><br><span class="line">            该值允许跨边界优化的QoR优势，最终层次结构与RTL类似，以便于分析。</span><br></pre></td></tr></table></figure><h4 id="retiming"><a href="#retiming" class="headerlink" title="-retiming"></a>-retiming</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用途：</span><br><span class="line">    选项的作用是优化电路性能，特别是针对同一时钟域内的顺序路径。</span><br><span class="line">    具体来说，这个布尔选项可以通过在组合逻辑门或查找表 (LUT) 之间自动移动寄存器（寄存器平衡），来改善电路性能。</span><br><span class="line">    它保持电路的原始行为和延迟，不需要对RTL（寄存器传输级）源代码进行任何更改。</span><br></pre></td></tr></table></figure><h4 id="keep-equivalent-registers"><a href="#keep-equivalent-registers" class="headerlink" title="-keep_equivalent_registers"></a>-keep_equivalent_registers</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用途：</span><br><span class="line">    防止合并具有相同输入逻辑的寄存器。</span><br><span class="line">    并相同输入逻辑的寄存器可以带来资源节省和功耗降低，但可能带来的时序问题和对调试的影响。</span><br></pre></td></tr></table></figure><h4 id="resource-sharing"><a href="#resource-sharing" class="headerlink" title="-resource_sharing"></a>-resource_sharing</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">用途：</span><br><span class="line">    设置不同信号之间算术运算符的共享。</span><br><span class="line">值：</span><br><span class="line">    auto：</span><br><span class="line">        根据设计的时序情况自动决定是否进行资源共享。如果设计时序允许，工具会自动启用资源共享，以便在不影响时序的前提下，优化资源利用。</span><br><span class="line">    on：</span><br><span class="line">        强制启用算术运算符的资源共享，不考虑时序要求。通过共享资源来减少算术运算符的数量，从而节省芯片面积和功耗。</span><br><span class="line">    off：</span><br><span class="line">        不进行资源共享。每个信号保留独立的算术运算符，不共享资源，可能会导致更高的资源使用和功耗，但可以避免潜在的时序问题。</span><br></pre></td></tr></table></figure><h4 id="no-lc"><a href="#no-lc" class="headerlink" title="-no_lc"></a>-no_lc</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选中此选项时，关闭LUT合并。</span><br><span class="line">影响：</span><br><span class="line">    关闭LUT组合可能会导致更多的LUT被使用，从而增加资源消耗。</span><br><span class="line">    在某些情况下，关闭LUT组合可能会影响时序，因为组合LUT通常可以减少逻辑级数，改善时序路径。</span><br><span class="line">    对于某些设计者来说，关闭LUT组合可以提供更高的设计可控性，使他们能够更精细地控制电路行为。</span><br></pre></td></tr></table></figure><h4 id="no-timing-driven"><a href="#no-timing-driven" class="headerlink" title="-no_timing_driven"></a>-no_timing_driven</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不考虑时序影响，减少综合时间在早期设计阶段，快速生成原型以进行功能验证时，可以使用此选项来加快合成速度。</span><br><span class="line">可以快速估算资源利用情况。在某些调试和验证阶段，可以暂时禁用时序驱动合成，以便快速迭代测试设计修改。</span><br></pre></td></tr></table></figure><h4 id="sfcu"><a href="#sfcu" class="headerlink" title="-sfcu"></a>-sfcu</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在单文件编译单元模式下运行合成。</span><br><span class="line">单文件编译单元模式可能提供更多的全局优化机会，因为综合工具可以看到所有源文件中的全部设计内容，从而进行更有效的优化。</span><br><span class="line">处理整个设计的综合可能会需要更多的电脑内存以及编译时间。</span><br></pre></td></tr></table></figure><h2 id="布局布线-Implementation"><a href="#布局布线-Implementation" class="headerlink" title="布局布线 (Implementation)"></a>布局布线 (Implementation)</h2><blockquote><p>参考: UG904 Vivado Design Suite User Guide : Implementation</p></blockquote><h3 id="Opt-Design"><a href="#Opt-Design" class="headerlink" title="Opt Design"></a>Opt Design</h3><p>优化逻辑设计，使其更容易适应目标Xilinx设备。</p><h4 id="directive-1"><a href="#directive-1" class="headerlink" title="-directive"></a>-directive</h4><ol><li>Explore</li></ol><ul><li>功能：运行多次优化过程。</li><li>特点：<ul><li>进行多次迭代优化，以全面提升设计性能和质量。</li><li>适用于需要全面优化的设计。</li></ul></li></ul><ol start="2"><li>ExploreArea</li></ol><ul><li>功能：运行多次优化过程，重点在于减少组合逻辑。</li><li>特点：<ul><li>通过多次优化迭代，减少组合逻辑的使用，以节省芯片面积。</li><li>适用于对面积有严格要求的设计。</li></ul></li></ul><ol start="3"><li>AddRemap</li></ol><ul><li>功能：运行默认逻辑优化流程，并包括LUT重新映射以减少逻辑级别。</li><li>特点：<ul><li>通过LUT重新映射，减少逻辑级别，优化设计的时序性能和面积。</li><li>适用于需要优化逻辑级别的设计。</li></ul></li></ul><ol start="4"><li>ExploreSequentialArea</li></ol><ul><li>功能：运行多次优化过程，重点在于减少寄存器和相关的组合逻辑。</li><li>特点：<ul><li>通过减少寄存器和相关的组合逻辑，优化面积和功耗。</li><li>适用于包含大量寄存器的设计。</li></ul></li></ul><ol start="5"><li>RuntimeOptimized</li></ol><ul><li>功能：运行最少的优化过程，以更快的运行时间换取较低的设计性能。</li><li>特点：<ul><li>优先考虑快速运行时间，可能会牺牲一些设计性能。</li><li>适用于时间紧迫的项目。</li></ul></li></ul><ol start="6"><li>NoBramPowerOpt</li></ol><ul><li>功能：运行所有默认的opt_design优化，但不包括块RAM功耗优化。</li><li>特点：<ul><li>保持所有默认优化，但省略块RAM功耗优化，可能会影响功耗表现。</li><li>适用于对功耗优化要求不高的设计。</li></ul></li></ul><ol start="7"><li>ExploreWithRemap</li></ol><ul><li>功能：与Explore指令相同，但包括重新映射优化。</li><li>特点：<ul><li>通过多次优化迭代和重新映射优化，提高设计性能和质量。</li><li>适用于需要全面优化和逻辑重新映射的设计。</li></ul></li></ul><ol start="8"><li>Default</li></ol><ul><li>功能：运行opt_design默认设置。</li><li>特点：<ul><li>使用工具的默认优化设置，适用于不需要特殊优化的设计。</li><li>提供一个平衡的优化方案，适合大多数设计需求。</li></ul></li></ul><p>从指令表上看 ExploreSequentialArea 最为优化最为全面和激进，其他选项是专门优化某方面的。</p><h3 id="Power-Opt-Design-optional"><a href="#Power-Opt-Design-optional" class="headerlink" title="Power Opt Design (optional):"></a>Power Opt Design (optional):</h3><p>优化设计元素，降低目标赛灵思器件的功耗需求。</p><h3 id="Place-Design"><a href="#Place-Design" class="headerlink" title="Place Design"></a>Place Design</h3><p>将设计放置到目标Xilinx设备上，并执行扇出复制以改善时序</p><h4 id="directive-2"><a href="#directive-2" class="headerlink" title="-directive"></a>-directive</h4><ol><li>Explore</li></ol><ul><li>功能：在详细放置和后放置优化中投入更高的放置器努力。</li><li>特点：<ul><li>在详细放置阶段投入更多资源和算法，提高放置精度。</li><li>在后放置优化阶段进一步优化设计，提高整体性能。</li></ul></li></ul><ol start="2"><li>WLDrivenBlockPlacement</li></ol><ul><li>功能：基于连线长度驱动的RAM和DSP块放置。通过减少块之间的连线距离来替代时序驱动放置。</li><li>特点：<ul><li>通过最小化RAM和DSP块连接的距离，改善块之间的时序。</li><li>适用于需要优化RAM和DSP块时序的设计。</li></ul></li></ul><ol start="3"><li>EarlyBlockPlacement</li></ol><ul><li>功能：基于时序驱动的RAM和DSP块放置。在放置过程的早期确定这些块的位置，并用作放置剩余逻辑的锚点。</li><li>特点：<ul><li>提早确定RAM和DSP块位置，作为其他逻辑单元放置的参考点。</li><li>改善整体设计的时序性能和布局稳定性。</li></ul></li></ul><ol start="4"><li>ExtraNetDelay_high &amp; ExtraNetDelay_low</li></ol><ul><li>功能：增加高扇出和长距离网络的估计延迟。</li><li>特点：<ul><li>提高对高扇出和长距离网络的延迟估计，从而优化关键路径时序。</li><li>高级别（high）：应用最高程度的悲观估计，适用于时序非常严格的设计。</li><li>低级别（low）：应用最低程度的悲观估计，适用于稍微宽松的设计。</li></ul></li></ul><ol start="5"><li>SSI_SpreadLogic_high &amp; SSI_SpreadLogic_low</li></ol><ul><li>功能：在SSI设备中分散逻辑单元以避免拥堵区域。</li><li>特点：<ul><li>高级别（high）：实现最高程度的逻辑分散，适用于严重拥堵的设计。</li><li>低级别（low）：实现最小程度的逻辑分散，适用于轻微拥堵的设计。</li></ul></li></ul><ol start="6"><li>AltSpreadLogic_high, AltSpreadLogic_medium &amp; AltSpreadLogic_low</li></ol><ul><li>功能：在整个设备中分散逻辑单元以避免拥堵区域。</li><li>特点：<ul><li>高级别（high）：实现最高程度的逻辑分散。</li><li>中级别（medium）：实现中等程度的逻辑分散。</li><li>低级别（low）：实现最小程度的逻辑分散。</li></ul></li></ul><ol start="7"><li>ExtraPostPlacementOpt</li></ol><ul><li>功能：在后放置优化中投入更高的放置器努力。<ul><li>特点：</li><li>进一步优化放置后的设计，提高整体性能。</li></ul></li></ul><ol start="8"><li>ExtraTimingOpt</li></ol><ul><li>功能：在后期阶段使用一套替代算法进行时序驱动的放置。<ul><li>特点：</li><li>提高时序驱动放置的效果，优化关键路径时序。</li></ul></li></ul><ol start="9"><li>SSI_SpreadSLLs, SSI_BalanceSLLs, SSI_BalanceSLRs, SSI_HighUtilSLRs</li></ol><ul><li>功能：针对SSI设备的不同放置策略。</li><li>特点：<ul><li>SSI_SpreadSLLs：跨SLR分区，并为高连通性区域分配额外面积。</li><li>SSI_BalanceSLLs：跨SLR分区，尝试平衡SLR之间的SLL。</li><li>SSI_BalanceSLRs：跨SLR分区，平衡SLR之间的单元数量。</li><li>SSI_HighUtilSLRs：强制放置器尝试将逻辑单元放置得更紧密。</li></ul></li></ul><ol start="10"><li>RuntimeOptimized</li></ol><ul><li>功能：运行最少的迭代次数，以更快的运行时间换取较低的设计性能。</li><li>特点：<ul><li>优先考虑快速运行时间，可能会牺牲一些性能。</li></ul></li></ul><ol start="11"><li>Quick</li></ol><ul><li>功能：绝对最快的运行时间，非时序驱动，只执行使设计合法所需的最小操作。</li><li>特点：<ul><li>非常快速的编译，但不考虑时序优化，适用于对时序要求不高的设计或快速原型开发。</li></ul></li></ul><ol start="12"><li>Default</li></ol><ul><li>功能：使用默认设置运行place_design。</li><li>特点：<ul><li>提供一个平衡的优化方案，适合大多数设计需求。</li></ul></li></ul><h4 id="More-Options"><a href="#More-Options" class="headerlink" title="More Options"></a>More Options</h4><ol><li>-post_place_opt<blockquote><p>Post placement optimization is a placement optimization that can potentially improve critical<br>path timing at the expense of additional run time. The optimization is performed on a fully placed<br>design with timing violations. For each of the top few critical paths, the placer tries moving<br>critical cells to improve delay and commits new cell placements if they improve estimated delay.<br>For designs with longer run times and relatively more critical paths, these placement passes<br>might further improve timing.</p></blockquote></li></ol><p>选项post_place_opt是一种放置优化，它可以以额外的运行时间为代价，潜在地改善关键路径计时。优化是在有时间冲突的完全放置设计上进行的。对于前几个关键路径中的每一个，放置器尝试移动关键单元以改善延迟，如果它们改善了估计延迟，则提交新的单元放置。<br>对于具有较长运行时间和相对更关键路径的设计，这些放置通道可能会进一步改善时间。</p><h3 id="Phys-Opt-Design-optional"><a href="#Phys-Opt-Design-optional" class="headerlink" title="Phys Opt Design (optional)"></a>Phys Opt Design (optional)</h3><p>在放置后模式中，优化基于基于单元放置的时间估计。<br>物理优化会自动合并由于逻辑优化而产生的网表更改，并根据需要放置单元。<br>在后路由模式下，根据实际的路由延迟进行优化。除了根据逻辑变化和放置单元自动更新网表外，物理优化还可以根据需要自动更新路由。</p><h4 id="directive-3"><a href="#directive-3" class="headerlink" title="-directive"></a>-directive</h4><ol><li>Explore</li></ol><ul><li>功能：运行不同算法进行多次优化。</li><li>特性：<ul><li>包括对高扇出网络的复制。</li><li>SLR（Super Logic Region）跨越优化。</li><li>最后阶段称为关键路径优化（Critical Path Optimization），在所有端点时钟的顶部关键路径上运行一部分物理优化，无论时序裕量如何。</li></ul></li></ul><ol start="2"><li>ExploreWithHoldFix</li></ol><ul><li>功能：运行不同算法进行多次优化。</li><li>特性：<ul><li>包括保持违规修复。</li><li>SLR跨越优化。</li><li>对高扇出网络的复制。</li></ul></li></ul><ol start="3"><li>ExploreWithAggressiveHoldFix</li></ol><ul><li>功能：运行不同算法进行多次优化。</li><li>特性：<ul><li>包括激进的保持违规修复。</li><li>SLR跨越优化。</li><li>对高扇出网络的复制。</li></ul></li></ul><ol start="4"><li>AggressiveExplore</li></ol><ul><li>功能：与Explore类似，但使用不同的优化算法并设定更激进的目标。</li><li>特性：<ul><li>包括一个允许降低WNS（Worst Negative Slack）的SLR跨越优化阶段，之后在后续优化算法中恢复。</li><li>包括一个保持违规修复优化。</li></ul></li></ul><ol start="5"><li>AlternateReplication</li></ol><ul><li>功能：使用不同的算法执行关键单元复制。</li></ul><ol start="6"><li>AggressiveFanoutOpt</li></ol><ul><li>功能：使用不同的算法进行扇出相关优化，目标更激进。</li></ul><ol start="7"><li>AddRetime</li></ol><ul><li>功能：执行默认的物理优化设计流程，并添加寄存器重定时。</li></ul><ol start="8"><li>AlternateFlowWithRetiming</li></ol><ul><li>功能：执行更激进的复制、DSP和块RAM优化，并启用寄存器重定时</li></ul><h3 id="Route-Design"><a href="#Route-Design" class="headerlink" title="Route Design"></a>Route Design</h3><p>将设计路由到目标Xilinx设备。</p><h4 id="directive-4"><a href="#directive-4" class="headerlink" title="-directive"></a>-directive</h4><ol><li>Explore</li></ol><ul><li>功能：允许路由器在初始路由之后探索不同的关键路径放置。</li><li>特点：<ul><li>提供了更多的优化机会，以改善关键路径的时序性能。</li></ul></li></ul><ol start="2"><li>AggressiveExplore</li></ol><ul><li>功能：引导路由器进一步扩展其对关键路径的探索，同时保持原有的时序预算。</li><li>特点：<ul><li>路由器运行时间可能显著增加，因为路由器使用更激进的优化阈值来尝试满足时序约束。</li><li>适用于对时序要求非常严格的设计。</li></ul></li></ul><ol start="3"><li>NoTimingRelaxation</li></ol><ul><li>功能：防止路由器通过放松时序来完成布线。</li><li>特点：<ul><li>如果路由器难以满足时序，它会花更长时间尝试满足原始的时序约束。</li><li>确保设计严格符合时序要求，但可能会增加运行时间。</li></ul></li></ul><ol start="4"><li>MoreGlobalIterations</li></ol><ul><li>功能：在所有阶段使用详细的时序分析，而不仅仅是在最后阶段，并且即使时序只略有改善，也会运行更多的全局迭代。</li><li>特点：<ul><li>通过反复迭代和详细分析来优化时序性能。</li><li>适用于需要细致时序优化的设计。</li></ul></li></ul><ol start="5"><li>HigherDelayCost</li></ol><ul><li>功能：调整路由器的内部成本函数，以强调延迟而非迭代次数，从而允许通过增加运行时间来换取更好的性能。</li><li>特点：<ul><li>在性能和运行时间之间做出权衡，以实现更好的时序表现。</li><li>适用于愿意增加运行时间以获得最佳性能的设计。</li></ul></li></ul><ol start="6"><li>RuntimeOptimized</li></ol><ul><li>功能：运行最少的迭代次数，以更快的运行时间换取较低的设计性能。</li><li>特点：<ul><li>优先考虑快速编译时间，但可能会牺牲一些性能。</li><li>适用于时间紧迫的项目。</li></ul></li></ul><ol start="7"><li>AlternateCLBRouting</li></ol><ul><li>功能：选择需要额外运行时间但可能有助于解决布线拥堵的替代路由算法。</li><li>特点：<ul><li>适用于存在布线拥堵问题的设计，通过替代算法可能改善布线质量。</li></ul></li></ul><ol start="8"><li>Quick</li></ol><ul><li>功能：绝对最快的编译时间，非时序驱动，仅执行使设计合法所需的最小操作。</li><li>特点：<ul><li>非常快速的编译，但不考虑时序优化。</li><li>适用于对时序要求不高的设计或快速原型开发。</li></ul></li></ul><h3 id="Write-Bitstream"><a href="#Write-Bitstream" class="headerlink" title="Write Bitstream"></a>Write Bitstream</h3><p>生成用于Xilinx设备配置的比特流。</p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GTX光通信</title>
      <link href="//article/GTXOpticalCommunication.html"/>
      <url>//article/GTXOpticalCommunication.html</url>
      
        <content type="html"><![CDATA[<h2 id="信息来源"><a href="#信息来源" class="headerlink" title="信息来源"></a>信息来源</h2><p>设备 : ZYNQ</p><p>技术手册 : Zynq 7000 SoC Technical Reference Manual (Zynq 7000 SoC技术参考手册)</p><p>参考该技术手册第21章节 <em>Input&#x2F;Output</em> 小节下 <em>GTX Low-Power Serial Transceivers</em> 器件说明,其中可以获取到ZYNQ各个收发器对应的物理引脚约束信息。<br>在 <em>Out-of-Band Signaling</em> 项目下提到:</p><blockquote><p>For more details on GTX Transceivers, see 7 Series FPGAs GTX Transceiver User Guide (UG476).</p></blockquote><p>或者进入 <em>Vivado</em> 在 <em>IP core</em> 的 <em>IDE</em> 界面的 <em>Documentation</em> -&gt; <em>Product Guide</em> 可以获取对应 IP 文档。</p><h2 id="GTX-时钟"><a href="#GTX-时钟" class="headerlink" title="GTX 时钟"></a>GTX 时钟</h2><p>一个 <strong>Quad</strong> 包含4个收发器以及一个 <strong>GTXE2_COMMON</strong> 资源,无论用户在IDE中选择 QPLL还是CPLL,<strong>GTXE2_COMMON</strong>都会被例化,因此使用同一个<strong>Quad</strong>的不同收发器的例化时候需要注意,若直接使用 <strong>example design</strong> 有可能出现 <strong>gtwizard_0_common</strong> 资源冲突.解决方式就是在IDE中选择 <strong>Include the shared logic in the example design</strong> 分别例化两组收发器,然后将使用CPLL时钟的收发器例化文件中的 <strong>GTXE2_COMMON</strong> 例化去掉即可。</p><p>GTX收发器中的CPLL标称工作范围在1.6 GHz到3.3 GHz之间。GTH收发器CPLL的标称工作范围为1.6 GHz ~ 5.16 GHz。7系列fpga收发器向导根据应用需求选择合适的CPLL设置.大于以上速率必须使用QPLL。</p><h2 id="GTX-复位"><a href="#GTX-复位" class="headerlink" title="GTX 复位"></a>GTX 复位</h2><h3 id="TX-复位"><a href="#TX-复位" class="headerlink" title="TX 复位"></a>TX 复位</h3><p>GTX&#x2F;GTH收发器TX使用复位状态机控制复位过程。初始化TX必须在顺序模式下使用 <em>GTTXRESET</em> <strong>激活 GTTXRESET(gtx_gttxreset_in) 输入可以自动触发一个完整的异步TX重置</strong>。</p><h4 id="GTX-GTH收发器TX复位状态机顺序"><a href="#GTX-GTH收发器TX复位状态机顺序" class="headerlink" title="GTX&#x2F;GTH收发器TX复位状态机顺序"></a>GTX&#x2F;GTH收发器TX复位状态机顺序</h4><ol><li>驱动 GTTXRESET  为 High，收发器等待 GTTXRESET  转变为 Low 后开始复位序列。</li><li>驱动 TXPMARESET 为 High，收发器等待 TXPMARESET 转变为 Low 后开始复位 PMA。</li><li>驱动 TXPCSRESET 为 High，收发器等待 TXPCSRESET 转变为 Low 后开始复位 PCS。</li><li>等待 TXRESETDONE 为 High。</li></ol><p>注意:只有 TXUSERRDY 为高 TXRESETDONE 才能驱动为高。也只有 TXUSERRDY 为高 才能驱动 PCS 复位。</p><p>当需要时，顺序模式允许用户从激活 TXPMARESET(gtx_txpmareset_in) 复位TX，并继续复位状态机，<strong>直到 TXRESETDONE(gt0_txresetdone_out) 从 Low 转换到 High 。</strong></p><p>如果使用一个MMCM来生成TXUSRCLK和TXUSRCLK2，那么可以用其 LOCK 信号驱动 TXUSERRDY . 在复位 PCS 之前 必须驱动 TXUSERRDY 为高。</p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ZYNQ Uboot编译</title>
      <link href="//article/"/>
      <url>//article/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/overview">Xilinx Wiki</a></p><h2 id="Uboot下载"><a href="#Uboot下载" class="headerlink" title="Uboot下载"></a>Uboot下载</h2><ul><li>GitHub下载源码,地址<a href="https://github.com/Xilinx/u-boot-xlnx.git">https://github.com/Xilinx/u-boot-xlnx.git</a></li><li>下载主分支即可,不必听从网上教程下载与Vivado版本号相同的分支</li></ul><blockquote><p>Versioning:<br>Starting with the release in October 2008, the names of the releases<br>were changed from numerical release numbers without deeper meaning<br>into a time stamp based numbering. Regular releases are identified by<br>names consisting of the calendar year and month of the release date.<br>Additional fields (if present) indicate release candidates or bug fix<br>releases in “stable” maintenance trees.<br>Examples:<br>    U-Boot v2009.11    - Release November 2009<br>    U-Boot v2009.11.1   - Release 1 in version November 2009 stable tree<br>    U-Boot v2010.09-rc1 - Release candidate 1 for September 2010 release<br>(从 2008 年 10 月发布开始，版本的名称从数字版本号更改而来，没有更深层次的含义转换为基于时间戳的编号。常规版本由以下人员标识名称由发布日期的日历年和月份组成。其他字段（如果存在）表示候选版本或错误修复在“稳定”维护树中发布。)  </p></blockquote><ul><li>使用旧版Vivado编译生成布局文件,若uboot启动失败或遇到其他问题再尝试回退同版本验证.</li></ul><h2 id="Uboot编译"><a href="#Uboot编译" class="headerlink" title="Uboot编译"></a>Uboot编译</h2><p>切换至下载目录,执行以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-linux-gnueabihf- <span class="comment">#设置交叉编译器前缀</span></span><br><span class="line"><span class="built_in">export</span> ARCH=arm <span class="comment">#设置目标架构</span></span><br><span class="line">make xilinx_zynq_virt_defconfig <span class="comment">#编译配置文件</span></span><br><span class="line">make <span class="comment">#编译uboot</span></span><br></pre></td></tr></table></figure><p>对于使用版本高于2020.1的uboot源码编译ZYNQ的uboot,xilinx 制作了统一的配置文件xilinx_zynq_virt_defconfig.这在Xilinx Wiki提到:</p><blockquote><p>Configuring U-Boot (&gt;&#x3D; 2020.1 Release)<br>After the build process completes the target u-boot elf-file is created in the top level source directory, named . Additionally in the tools&#x2F; directory the  utility is created, which is used in other tasks to wrap images into u-boot format.u-boot&#x2F;u-boot.elfmkimage</p></blockquote><p>其他版本或FPAG系列具体参考网站说明<a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18841973/Build+U-Boot#BuildU-Boot-ConfiguringU-Boot(%3E=2020.1Release)">Build U-boot</a>.</p><p>或使用脚本就不需要指定环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- xilinx_zynq_virt_defconfig</span><br><span class="line">make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12</span><br></pre></td></tr></table></figure><p>编译完成后再当前目录可以看到<code>u-boot.elf</code></p><h2 id="烧录Falsh"><a href="#烧录Falsh" class="headerlink" title="烧录Falsh"></a>烧录Falsh</h2><p>使用SDK或者Vitis制作boot.bin文件,主要步骤如下:</p><ol><li>使用VIVADO生成Block Design根据原理图初始化FLASH或SD卡相关配置,初始化UART配置,导出硬件布局文件<code>.xsa</code></li><li>使用vitis创建域,创建时候勾选初始化引导文件,这样创建成功后可以在域中找到FSBL.elf文件而不需要额外创建FSBL应用.</li><li>使用Vitis制作BOOT.bin文件后使用Vivado烧录,或直接使用Vitis烧录也行</li></ol><p>以上介绍大概步骤,具体细节可根据步骤参考网上教程.</p><p><strong>注意:</strong> 若VIVADO烧写出错,可尝试将<code>Verify</code>勾选去掉重启Vivado后尝试烧写.</p><hr><p>2024年6月7日更新: 使用Vivado2022版本烧写Flash时失败,多次尝试后发现Flash锁死,建议按照以上步骤使用SD卡启动,Flash解锁步骤还在摸索中…</p><p>SD卡文件可以在编译后的sd_card目录中找到BOOT.bin文件,将其放到SD中就可以启动.</p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关闭Bing搜索后的动态UI效果</title>
      <link href="//article/closeBingUI.html"/>
      <url>//article/closeBingUI.html</url>
      
        <content type="html"><![CDATA[<ol><li>点击Edge右上角三个点</li><li>选择设置</li><li>选择隐私、搜索和服务</li><li>下滑到服务栏，点击地址栏和搜索</li><li>点击添加<br>搜索引擎:随意起一个名字<br>快捷方式:随意<br>URL:<a href="https://bing.com/search?q=%25s">https://bing.com/search?q=%s</a></li><li>保存退出后找到刚刚添加的搜索引擎，点击右侧三个小点选为默认引擎即可。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>打游戏最好的电脑配置!</title>
      <link href="//article/The_Best_Config_Of_Game.html"/>
      <url>//article/The_Best_Config_Of_Game.html</url>
      
        <content type="html"><![CDATA[<h1 id="饥荒联机版"><a href="#饥荒联机版" class="headerlink" title="饥荒联机版"></a><center>饥荒联机版</center></h1><p><img src="https://s2.loli.net/2024/04/02/V8z3uHURDjEghk6.jpg" alt="从左到右: 乾三申、村雨、原一色、KamAris、香八宝"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo | Butterfly 主题美化</title>
      <link href="//article/blogsetting.html"/>
      <url>//article/blogsetting.html</url>
      
        <content type="html"><![CDATA[<!-- <div class="note modern"><p>none</p></div><div class="note default modern"><p>default</p></div><div class="note primary modern"><p>primary</p></div><div class="note success modern"><p>success</p></div><div class="note info modern"><p>info</p></div><div class="note warning modern"><p>warning</p></div><div class="note danger modern"><p>danger</p></div> --><div class="note info modern"><p>文章对主题<code>_config.yml</code>与<code>_config.butterfly.yml</code>文件的修改不做记录。若有看不懂的地方，请先认真阅读<a href="https://butterfly.js.org/posts/21cfbf15/">安装文档</a>后欢迎评论或邮件提问探讨。</p></div><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本站使用Hexo框架搭建，主题为Butterfly。</p><p>本篇为本博客更改主题文件配置信息，为有需要做相同修改的朋友，或者将来主题更新适配留作说明。</p><h2 id="修改首页标题显示"><a href="#修改首页标题显示" class="headerlink" title="修改首页标题显示"></a>修改首页标题显示</h2><p>博客首页标题默认显示为<code>_config.yml</code>文件中配置的<code>title</code>项目。<br>在<code>/themes/butterfly/layout/includes/header/index.pug</code>文件中找到<code>site_title</code>变量赋值处，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- var site_title = page.title || page.tag || page.category || config.title</span><br></pre></td></tr></table></figure><p>这句话的意思是，该页面显示的标题有优先级，先后取自，文章标题，标签，分类，<code>_config.yml</code>文件<code>title</code>项。</p><p>想自定义首页标题，在<code>config.title</code>项前添加<code>theme.blog_name</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- var site_title = page.title || page.tag || page.category || theme.blog_name || config.title</span><br></pre></td></tr></table></figure><p>而后去<code>_config.butterfly.yml</code>随意找一处(建议在开头)添加配置项<code>blog_name</code>，本站配置如下，不需要缩进。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">blog_name:</span> <span class="string">雾里看花，刹那芳华</span></span><br></pre></td></tr></table></figure><h2 id="修改顶部导航栏搜索图标排序"><a href="#修改顶部导航栏搜索图标排序" class="headerlink" title="修改顶部导航栏搜索图标排序"></a>修改顶部导航栏搜索图标排序</h2><p>找到文件<code>/themes/butterfly/layout/includes/header/nav.pug</code>修改将菜单配置移到搜索配置之前，注释掉搜索文字就可以只得到一个搜索按钮，希望保留的可以不注释<code>- span=&#39; &#39;+_p(&#39;search.title&#39;)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">nav#nav</span><br><span class="line">  span#blog-info</span><br><span class="line">    a(href=url_for(&#x27;/&#x27;) title=config.title)</span><br><span class="line">      if theme.nav.logo</span><br><span class="line">        img.site-icon(src=url_for(theme.nav.logo))</span><br><span class="line">      if theme.nav.display_title</span><br><span class="line">        span.site-name=config.title</span><br><span class="line">    </span><br><span class="line">  #menus</span><br><span class="line">    !=partial(&#x27;includes/header/menu_item&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">    if (theme.algolia_search.enable || theme.local_search.enable || theme.docsearch.enable)</span><br><span class="line">      #search-button</span><br><span class="line">        a.site-page.social-icon.search(href=&quot;javascript:void(0);&quot;)</span><br><span class="line">          i.fas.fa-search.fa-fw</span><br><span class="line">          //- span=&#x27; &#x27;+_p(&#x27;search.title&#x27;)</span><br><span class="line">    //- !=partial(&#x27;includes/header/menu_item&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line"></span><br><span class="line">    #toggle-menu</span><br><span class="line">      a.site-page(href=&quot;javascript:void(0);&quot;)</span><br><span class="line">        i.fas.fa-bars.fa-fw</span><br></pre></td></tr></table></figure><h2 id="修改侧栏作者卡"><a href="#修改侧栏作者卡" class="headerlink" title="修改侧栏作者卡"></a>修改侧栏作者卡</h2><p>找到文件<code>/themes/butterfly/layout/includes/widget/card_author.pug</code><br>我将以下代码注释后获得了简洁的卡片内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">if theme.aside.card_author.enable</span><br><span class="line">  .card-widget.card-info</span><br><span class="line">    .is-center</span><br><span class="line">      .avatar-img</span><br><span class="line">        img(src=url_for(theme.avatar.img) onerror=`this.onerror=null;this.src=&#x27;` + url_for(theme.error_img.flink) + `&#x27;` alt=&quot;avatar&quot;)</span><br><span class="line">      .author-info__name= config.author</span><br><span class="line">      .author-info__description!= theme.aside.card_author.description || config.description</span><br><span class="line"></span><br><span class="line">    //- .card-info-data.site-data.is-center</span><br><span class="line">    //-   a(href=url_for(config.archive_dir) + &#x27;/&#x27;)</span><br><span class="line">    //-     .headline= _p(&#x27;aside.articles&#x27;)</span><br><span class="line">    //-     .length-num= site.posts.length</span><br><span class="line">    //-   a(href=url_for(config.tag_dir) + &#x27;/&#x27;)</span><br><span class="line">    //-     .headline= _p(&#x27;aside.tags&#x27;)</span><br><span class="line">    //-     .length-num= site.tags.length</span><br><span class="line">    //-   a(href=url_for(config.category_dir) + &#x27;/&#x27;)</span><br><span class="line">    //-     .headline= _p(&#x27;aside.categories&#x27;) </span><br><span class="line">    //-     .length-num= site.categories.length</span><br><span class="line"></span><br><span class="line">    if theme.aside.card_author.button.enable</span><br><span class="line">      a#card-info-btn(href=theme.aside.card_author.button.link)</span><br><span class="line">        i(class=theme.aside.card_author.button.icon)</span><br><span class="line">        span=theme.aside.card_author.button.text</span><br><span class="line">  </span><br><span class="line">    if(theme.social)</span><br><span class="line">        .card-info-social-icons.is-center</span><br><span class="line">          !=partial(&#x27;includes/header/social&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="固定导航栏"><a href="#固定导航栏" class="headerlink" title="固定导航栏"></a>固定导航栏</h2><p>找到文件<code>/themes/butterfly/source/js/main.js</code>，修改网页滑动逻辑判定,全篇代码太长，仅给出有做修改段代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// let flag = &#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> scrollTask = btf.<span class="title function_">throttle</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> currentTop = <span class="variable language_">window</span>.<span class="property">scrollY</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span></span><br><span class="line">    <span class="keyword">const</span> isDown = <span class="title function_">scrollDirection</span>(currentTop)</span><br><span class="line">    <span class="keyword">if</span> (currentTop === <span class="number">0</span>) &#123;</span><br><span class="line">      $header.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;nav-fixed&#x27;</span>, <span class="string">&#x27;nav-visible&#x27;</span>)</span><br><span class="line">      isChatBtn &amp;&amp; <span class="variable language_">window</span>.<span class="property">chatBtn</span>.<span class="title function_">show</span>()</span><br><span class="line">      $rightside.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;rightside-show&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      $rightside.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;rightside-show&#x27;</span>)</span><br><span class="line">      isChatBtn &amp;&amp; <span class="variable language_">window</span>.<span class="property">chatBtn</span>.<span class="title function_">hide</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if (currentTop &gt; 56) &#123;</span></span><br><span class="line">    <span class="comment">//   if (flag === &#x27;&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//     $header.classList.add(&#x27;nav-fixed&#x27;)</span></span><br><span class="line">    <span class="comment">//     $rightside.classList.add(&#x27;rightside-show&#x27;)</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//   if (isDown) &#123;</span></span><br><span class="line">    <span class="comment">//     if (flag !== &#x27;down&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//       $header.classList.remove(&#x27;nav-visible&#x27;)</span></span><br><span class="line">    <span class="comment">//       isChatBtn &amp;&amp; window.chatBtn.hide()</span></span><br><span class="line">    <span class="comment">//       flag = &#x27;down&#x27;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//   &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//     if (flag !== &#x27;up&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//       $header.classList.add(&#x27;nav-visible&#x27;)</span></span><br><span class="line">    <span class="comment">//       isChatBtn &amp;&amp; window.chatBtn.show()</span></span><br><span class="line">    <span class="comment">//       flag = &#x27;up&#x27;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//   flag = &#x27;&#x27;</span></span><br><span class="line">    <span class="comment">//   if (currentTop === 0) &#123;</span></span><br><span class="line">    <span class="comment">//     $header.classList.remove(&#x27;nav-fixed&#x27;, &#x27;nav-visible&#x27;)</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">//   $rightside.classList.remove(&#x27;rightside-show&#x27;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    isShowPercent &amp;&amp; <span class="title function_">rightsideScrollPercent</span>(currentTop)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollHeight</span> &lt;= innerHeight) &#123;</span><br><span class="line">      $rightside.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;rightside-show&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">  btf.<span class="title function_">addEventListenerPjax</span>(<span class="variable language_">window</span>, <span class="string">&#x27;scroll&#x27;</span>, scrollTask, &#123; <span class="attr">passive</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加个人GitHub贡献度日历"><a href="#添加个人GitHub贡献度日历" class="headerlink" title="添加个人GitHub贡献度日历"></a>添加个人GitHub贡献度日历</h2><p>参考博客<a href="https://blog.meta-code.top/2022/03/15/2022-41/">百里飞洋 Barry-Flynn</a>，感谢大佬解答，以及提供了插件以及后端API维护,请前往其仓库了解详情。</p><ul><li><p><a href="https://github.com/Barry-Flynn/hexo-github-calendar">前端Hexo插件</a></p></li><li><p><a href="https://github.com/Barry-Flynn/python_github_calendar_api">后端API部署</a></p><div class="note warning modern"><p>Vercel域名被墙，需要用自己的域名做解析。</p></div></li></ul><h3 id="2024年3月29日更新"><a href="#2024年3月29日更新" class="headerlink" title="2024年3月29日更新"></a>2024年3月29日更新</h3><p>今天API失效了,GitHub应该添加了请求头,在<a href="https://blog.meta-code.top/2022/03/15/2022-41/">百里飞洋 Barry-Flynn</a>提供API基础的前提上,我做了修改提交到了我的仓库<a href="https://github.com/yuhengwei2001/python_github_calendar_api">python_github_calendar_api</a>.有需要的可以自行查看。</p><h2 id="设置动态星空背景"><a href="#设置动态星空背景" class="headerlink" title="设置动态星空背景"></a>设置动态星空背景</h2><p>参考<a href="https://blog.meta-code.top/2021/09/30/2021-7/">【Hexo博客】如何使博客拥有星空背景和流星特效</a><br>背景图片来源<a href="https://www.zhihu.com/question/26724767">星际穿越壁纸</a> </p>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>傅里叶变换原理(简易)</title>
      <link href="//article/FFT.html"/>
      <url>//article/FFT.html</url>
      
        <content type="html"><![CDATA[<!-- >由实际应用倒推算法原理，暴力拆解傅里叶变换(Fourier Transform)的信号处理上的原理。尽量摒弃繁杂的数学定义了解，直观的描述快速傅里叶到底对信号做了什么处理？阅读本文章的可以是对傅里叶变换公式推导毫无了解的朋友，因为这篇文章不从推导入手，而直接傅里叶变换公式入手，告诉你如何通过一系列的操作得到信号的频域图。至于如何推导傅里叶变换公式等以后有空再写一篇吧！感兴趣的朋友可以先去网上搜索一番。more --><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><h3 id="连续与离散"><a href="#连续与离散" class="headerlink" title="连续与离散"></a>连续与离散</h3><p>一般人们口中所说的傅里叶变换都是指连续傅里叶变换，针对的是连续时域信号。维基百科上是这么描述<a href="https://zh.wikipedia.org/wiki/%E8%BF%9E%E7%BB%AD%E4%BF%A1%E5%8F%B7"><strong>连续信号</strong></a>的：</p><blockquote><p>连续信号或称连续时间信号是指定义在实数域的信号，自变量（一般是时间）的取值连续。若信号的幅值和自变量均连续，则称为模拟信号。根据实数的性质，时间参数的连续性意味着信号的值在时间的任意点均有定义。</p></blockquote><p>简单来说，对于一个sin函数的连续信号，其波形长这样:</p><center><img src="https://s2.loli.net/2024/03/08/GWz9RA8xyJgZvcp.png"/></center><p>对于计算设备的信号处理，因为采样设备的采样率是有限的。因此得到的采样信号都是离散的，所以就有了针对离散信号的离散傅里叶变换。维基百科是这么描述<a href="https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E4%BF%A1%E5%8F%B7"><strong>离散信号</strong></a>:</p><blockquote><p>离散信号是在连续信号上采样得到的信号。与连续信号的自变量是连续的不同，离散信号是一个串行，即其自变量是“离散”的。这个串行的每一个值都可以被看作是连续信号的一个采样。由于离散信号只是采样的串行，并不能从中获得采样率，因此采样率必须另外存储。以时间为自变量的离散信号为离散时间信号。<br>离散信号并不等同于数字信号。数字信号不仅是离散的，而且是经过量化的。即，不仅其自变量是离散的，其值也是离散的。因此离散信号的精度可以是无限的，而数字信号的精度是有限的。而有着无限精度，亦即在值上连续的离散信号又叫抽样信号。所以离散信号包括了数字信号和抽样信号。</p></blockquote><center><img src="https://s2.loli.net/2024/03/08/Ui76ryaEOM3FGHl.png"/></center><h3 id="傅里叶变换公式实际意义"><a href="#傅里叶变换公式实际意义" class="headerlink" title="傅里叶变换公式实际意义"></a>傅里叶变换公式实际意义</h3><p>直接看傅里叶变换公式：</p><p>$$<br>\begin{align}<br>{F}(\omega) &#x3D; \int_{-\infty}^{\infty} f(t)e^{-j\omega t}dt<br>\end{align}<br>$$</p><p>其中</p><ul><li>$f(t)$频谱未知信号，我们就是对这个信号做傅里叶变换。</li><li>$F(\omega)$为傅里叶变换后的频谱函数。其自变量为$\omega$频率。</li><li>$e^{-j\omega t}$为复信号</li></ul><p>要理解这个公式，关键就在于$e^{-j\omega t}$怎么理解。本科学过复变函数的同学应该都知道，指数复变函数是可以转化为三角函数形式的。其变换公式如下:</p><p>$$<br>\begin{align}<br>e^{-j\omega t} &#x3D; cos(\omega t)-jsin(\omega t)<br>\end{align}<br>$$</p><p>那么将（2）式代入（1）式可以很快得出:<a id="公式3"></a></p><p>$$<br>\begin{align}<br>{F}(\omega) &#x3D; \int_{-\infty}^{\infty} f(t)(cos(\omega t)-jsin(\omega t))dt<br>\end{align}<br>$$<br>由上式可得，<strong>要想得到信号频域与相位信息只需要将信号与复数信号做乘法后积分</strong>。</p><h3 id="信号的筛选"><a href="#信号的筛选" class="headerlink" title="信号的筛选"></a>信号的筛选</h3><p>简单概括公式所表达的实际意义后，我们再来看为什么要这么做。废话少说直接按照傅里叶变换公式所描述的做法，将信号与各已频率信号乘法后积分，写一段简单的matlab程序。最终结果如下图:</p><center><img src="https://s2.loli.net/2024/03/11/fDb6sMc3rzO1Pen.gif"/></center><ul><li>框图1内蓝色信号线为MATLAB生成需要做傅里叶变换的随机频率的信号(未知信号)，红色信号线为频率不断增大的正弦信号，红色信号是人为生成的(基信号)，因此其频率是可知的。</li><li>框图2为两正弦波相乘结果。</li><li>框图3是对正弦波乘积结果的积分。</li></ul><p>从图上可以很清楚直观的看出，当未知信号与基信号频率相同时，他们乘积的积分达到了最大。而这个积分最终的图像是不是就很像信号经过傅里叶变换后的频域图像呢！利用了乘法负负得正的特性，当基信号与未知信号频率完全相同的时候，其时域上乘积全为正数。因此，此时的积分达到最大值。通过此类操作即可得到未知信号的频率。</p><p><strong>说人话，就是用各种频率的基信号与未知信号做对比，看看哪个频率的基信号与未知信号最像！！！，而这个对比的方法，用数学来描述就是先相乘后积分，这样描述的话，是不是听起来就没那么复杂了。</strong></p><p>用公式描述就是：<a id="公式4"></a><br>$$<br>\begin{align}<br>{F}(\omega) &#x3D; \int_{-\infty}^{\infty}f(t)sin(\omega t)dt<br>\end{align}<br>$$<br>可以看到,已经离上文所示的傅里叶变换公式(3)有点相像了！</p><blockquote><p><strong>Q:</strong> 单个频率成分信号可以，那多个呢？</p></blockquote><p>那自然也是这么做的，废话少说，直接上图：</p><center><img src="https://s2.loli.net/2024/03/11/PxkYMiIqDoy89uU.gif"/></center><p>由此可以看出，<strong>用这种方式可以筛选出未知信号中各种频率成分</strong>，至于为什么可以？前面说过了，本文只讨论傅里叶变换做法，暂不对其数学原理做深入探究，想要深入了解的朋友可以自行搜索，或关注我的博客，或许不久后将更新此方面的内容。</p><h3 id="初始相位的问题"><a href="#初始相位的问题" class="headerlink" title="初始相位的问题"></a>初始相位的问题</h3><p>上文所讨论的对未知信号频率的筛选，全部都是建立在未知信号相位为0的情况下。但是实际使用过程中，信号的相位与频率都是未知的，若只使用上文（4）所描述的方式肯定是不行的，如下图：</p><center><img src="https://s2.loli.net/2024/03/11/LiJkl3aSFY6C1qt.png"/></center><p>可以看到若未知信号的初始相位为90°，若还使用<a href="#%E5%85%AC%E5%BC%8F4"><strong>公式4</strong></a>，得出的结果与实际就有误了。</p><p>此时再回头看看傅里叶变换的公式，不难发现，<a href="#%E5%85%AC%E5%BC%8F3"><strong>傅里叶变换</strong></a>使用的是复数信号。$e^{-j\omega t} &#x3D; cos(\omega t)-jsin(\omega t)$。也就是说傅里叶变换对未知信号使用复数信号相乘后求积分。而不是只对单个正弦信号做比较。</p><p>不难看出，傅里叶变换的结果是复数信号，其结果实部的值就是表示未知信号与cos信号的相关度，虚部值表示未知信号与sin信号的相关度。由此可以看出，傅里叶变换的结果还包含了未知信号的相位信息。</p><p>为了分析其频率信息，我们可以对结果做取模开方处理，也就是:<br>$$<br>    \sqrt(R^2+I^2)<br>$$<br>结果如下图:</p><center><img src="https://s2.loli.net/2024/03/11/KoVuc13fFasLRWT.gif"/></center><p>可以看到位置信号的频率成分已经被解析出来了,这里注意一点,上文是做了开平方处理，也就是说解除了在正频域，在负频域也有频率分量。</p><h2 id="离散傅里叶变换-DFT"><a href="#离散傅里叶变换-DFT" class="headerlink" title="离散傅里叶变换(DFT)"></a>离散傅里叶变换(DFT)</h2><p>离散傅里叶变换实际上是按照傅里叶变换的定义对离散的数字信号进行计算，积分变成了连加，频率间隔根据采样点数的倒数确定,公式如下:</p><p>$$<br>X[k]&#x3D;\sum_{n&#x3D;0}^{N-1}{x[n]e^{-j(2\pi&#x2F;N)kn}}<br>$$</p><h3 id="采样带来的频谱镜像问题"><a href="#采样带来的频谱镜像问题" class="headerlink" title="采样带来的频谱镜像问题"></a>采样带来的频谱镜像问题</h3><p>为了对连续信号做傅里叶变换，我们需要对信号进行采样，采样后得到的离散信号才可以用于计算机计算，做DFT。这里有一个采样导致的镜像问题。</p><p>首先，根据奈奎斯特采样定理:</p><blockquote><p>要从抽样信号中无失真地恢复原信号，抽样频率应大于2倍信号最高频率。 抽样频率小于2倍频谱最高频率时，信号的频谱有混叠。 抽样频率大于2倍频谱最高频率时，信号的频谱无混叠。</p></blockquote><p>说白了，要保留信号的基本信息，我们需要对信号进行信号至少两倍频率的采样。而数字设备采样可以看作连续信号乘以采样频率的<a href="https://baike.baidu.com/item/%E7%8B%84%E6%8B%89%E5%85%8B%E6%A2%B3%E7%8A%B6%E5%87%BD%E6%95%B0/20393728">狄拉克梳状函数</a>。</p><p>这里需要注意一点，我刚刚的描述是<strong>连续信号乘以采样频率的狄拉克梳状函数</strong>，也就是说，采样实际上可以理解为被采样信号与采样信号相乘。根据卷积定理，<strong>信号时域相乘等于频域卷积</strong>。等于说被采样信号与采样信号做了混频。</p><p>假设被采样信号频率为100Hz，采样信号频率为1000Hz，那么对采样后的信号做DFT，在正频域上会得到100Hz，900Hz以及1100Hz的频谱。由于采样频率是1000Hz，因此在区间内会只有100Hz以及900Hz的频谱,这900Hz的频谱就是采样后离散信号的镜像。</p><ul><li><p>奈奎斯特低通采样实际局限性</p><p> 现如今通信设备采用的发送频率上到千兆，这对接收端ADC带来了很大的挑战。假设一个处于2GHz频段的信号，若要根据奈奎斯特（低通）采样率采样，则需要至少能做到4GHz的采样的ADC器件。先不说没有这么高频的采样芯片，就算有，成本也是巨大的。<br> 再者，虽然信号处于2GHz的频段，但确实带通信号，只有处于2GHz周围的频段被用作数据传输，带传输带宽之外的频域没有信息传递。因此若对2GHz信号进行低通采样会造成极大的资源浪费。<br> 但与单音信号不同的是，通信设备所发送的信号频率与带宽都是提前可知的，这对我们信号处理提供了有利条件。</p></li></ul><h3 id="带通采样"><a href="#带通采样" class="headerlink" title="带通采样"></a>带通采样</h3><p>带通采样的原理可以理解为，利用采样函数对被采样函数做频谱搬移。注意，频谱搬移需要避免频率混叠，具体推导以及原理这篇<a href="https://blog.csdn.net/weixin_45317919/article/details/131906305">博客</a>做了详细叙述。</p><p>有点技术手段的可以参考<a href="http://www.ws.binghamton.edu/fowler/fowler%20personal%20page/EE521_files/II-2%20BP%20Sampling_2007.pdf">这篇PDF</a></p><h2 id="FFT诞生历史"><a href="#FFT诞生历史" class="headerlink" title="FFT诞生历史"></a>FFT诞生历史</h2><p>1963年8月美、英、苏三国在莫斯科谈判，达成协议签定了该条约，全称为《关于禁止在大气层、外层空间和水下进行核武器爆炸实验的条约》又称〈部分核禁止条约〉或三家条约。可以注意到，条约中不包括地下核武器爆炸实验，这是因为地下核实验难以被检测到，大地隔绝了大部分的辐射，声音。使得其难以想地上或水下核试验一样容易被探测到。要想探测地下核试验，主要靠分析地动信息。但如何将日常地址活动造成的地动与核试验造成的地动区分开来成为了当时科学家所难以解决的问题。在快速傅里叶算法还未发现之前，按照离散傅里叶定义使用计算机对地动信号做频谱分析，算力远远不足，分析出的数据严重过时。因此在这个背景下，快速傅里叶变换的算法出现了。</p><h2 id="快速傅里叶变换-FFT"><a href="#快速傅里叶变换-FFT" class="headerlink" title="快速傅里叶变换(FFT)"></a>快速傅里叶变换(FFT)</h2><p>快速傅里叶算法本质上是对离散傅里叶变化的改进，本质上是利用矩阵乘法时不同基信号在奇数或偶数点的与被采样信号的乘积相同来减少计算，严格的数学推断可以参考这篇<a href="https://zhuanlan.zhihu.com/p/407885496">快速理解FFT算法（完整无废话）</a></p><h2 id="MATLAB-仿真代码"><a href="#MATLAB-仿真代码" class="headerlink" title="MATLAB 仿真代码"></a>MATLAB 仿真代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 设置时间范围</span></span><br><span class="line">t = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">freq1 = <span class="number">5</span>;</span><br><span class="line">freq2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建GIF文件</span></span><br><span class="line">filename = <span class="string">&#x27;sin_wave_animation.gif&#x27;</span>;</span><br><span class="line">fps = <span class="number">120</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化乘积结果的和</span></span><br><span class="line">sum_of_product = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(t));</span><br><span class="line">sum_of_product_sin = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(t));</span><br><span class="line">sum_of_product_cos = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(t));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(t)</span><br><span class="line">    <span class="comment">% 生成两个不同频率的正弦波</span></span><br><span class="line">    y1 = <span class="built_in">cos</span>(freq1 * t);</span><br><span class="line">    y2 = <span class="built_in">sin</span>((freq2+<span class="built_in">i</span>/<span class="number">10</span>) * t);</span><br><span class="line">    y3 = <span class="built_in">cos</span>((freq2+<span class="built_in">i</span>/<span class="number">10</span>) * t);</span><br><span class="line">    <span class="comment">% 计算两个正弦波的乘积</span></span><br><span class="line"></span><br><span class="line">    y_product_sin = y1 .* y2;</span><br><span class="line">    y_product_cos = y1 .* y3;</span><br><span class="line">    <span class="comment">% 计算乘积结果的和</span></span><br><span class="line">    sum_of_product_sin(<span class="built_in">i</span>+<span class="number">1</span>) = sum(y_product_sin);</span><br><span class="line">    sum_of_product_cos(<span class="built_in">i</span>+<span class="number">1</span>) = sum(y_product_cos);</span><br><span class="line">    </span><br><span class="line">    sum_of_product = <span class="built_in">sqrt</span>(power(sum_of_product_sin, <span class="number">2</span>) + power(sum_of_product_cos, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    arr = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">    subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">plot</span>(arr(<span class="number">1</span>:<span class="built_in">i</span>), sum_of_product_sin(<span class="number">1</span>:<span class="built_in">i</span>), <span class="string">&#x27;g&#x27;</span>); <span class="comment">% 只绘制当前时间点之前的数据</span></span><br><span class="line">    xlabel(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    ylabel(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">    xlim([<span class="number">0</span>, <span class="number">10</span>]);</span><br><span class="line">    ylim([<span class="number">-500</span>, <span class="number">500</span>]);</span><br><span class="line">    title(<span class="string">&#x27;Re&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    arr = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">    subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">plot</span>(arr(<span class="number">1</span>:<span class="built_in">i</span>), sum_of_product_cos(<span class="number">1</span>:<span class="built_in">i</span>), <span class="string">&#x27;g&#x27;</span>); <span class="comment">% 只绘制当前时间点之前的数据</span></span><br><span class="line">    xlabel(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    ylabel(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">    xlim([<span class="number">0</span>, <span class="number">10</span>]);</span><br><span class="line">    ylim([<span class="number">-500</span>, <span class="number">500</span>]);</span><br><span class="line">    title(<span class="string">&#x27;Im&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    arr = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">    subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">plot</span>(arr(<span class="number">1</span>:<span class="built_in">i</span>), sum_of_product(<span class="number">1</span>:<span class="built_in">i</span>), <span class="string">&#x27;g&#x27;</span>); <span class="comment">% 只绘制当前时间点之前的数据</span></span><br><span class="line">    xlabel(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    ylabel(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">    xlim([<span class="number">0</span>, <span class="number">10</span>]);</span><br><span class="line">    ylim([<span class="number">-500</span>, <span class="number">500</span>]);</span><br><span class="line">    title(<span class="string">&#x27;sqrt(power(Re, 2) + power(Im, 2));&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 保存当前图像为GIF</span></span><br><span class="line">    frame = getframe(gcf);</span><br><span class="line">    im = frame2im(frame);</span><br><span class="line">    [imind, cm] = rgb2ind(im, <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">i</span> == <span class="number">1</span></span><br><span class="line">        imwrite(imind, cm, filename, <span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;Loopcount&#x27;</span>, <span class="built_in">inf</span>, <span class="string">&#x27;DelayTime&#x27;</span>, <span class="number">1</span>/fps);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        imwrite(imind, cm, filename, <span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;WriteMode&#x27;</span>, <span class="string">&#x27;append&#x27;</span>, <span class="string">&#x27;DelayTime&#x27;</span>, <span class="number">1</span>/fps);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">i</span> == <span class="number">100</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GT Wizard 多通道问题</title>
      <link href="//article/GT_Wizard_MultiChannel_issue.html"/>
      <url>//article/GT_Wizard_MultiChannel_issue.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在使用Xilinx提供的GT Wizard IP核时例化了多个两个收发通道，前期测试时只接了通道0，测试正常。但后期接入通道1时出现问题。当我断开通道0，只连接通道1时，数据接收错乱了。多方查询后发现是使用Vivado生成的仿真例程有问题，修改例程文件中的时钟连接逻辑即可解决例化多通道时只使用单通道有可能出现数据时钟错乱的问题。</p></blockquote><span id="more"></span><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Vivado 2021.2.1</li><li>VScode Portable</li></ul><h2 id="分析解决"><a href="#分析解决" class="headerlink" title="分析解决"></a>分析解决</h2><h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><p>右键IP核生成IP仿真例程后，可以在工程列表中找到类似<code>gtwizard_0_GT_USRCLK_SOURCE。v</code>的文件，这是用于配置GTX时钟资源的文件，其中在末尾的发送与接收时钟输出的语句可以看到问题所在，<strong>例程在仿真时输出的时钟全部采用通道0的时钟，因此在综合后上板子调试后，若通道0空载，则输出的恢复时钟混乱造成数据处理时序混乱</strong>。代码如下:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Instantiate a MMCM module to divide the reference clock. Uses internal feedback</span></span><br><span class="line">    <span class="comment">// for improved jitter performance， and to avoid consuming an additional BUFG</span></span><br><span class="line"></span><br><span class="line">    BUFG txoutclk_bufg0_i</span><br><span class="line">    (</span><br><span class="line">        <span class="variable">.I</span>                              (gt0_txoutclk_i)，</span><br><span class="line">        <span class="variable">.O</span>                              (gt0_txusrclk_i)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    BUFG rxoutclk_bufg1_i</span><br><span class="line">    (</span><br><span class="line">        <span class="variable">.I</span>                              (gt0_rxoutclk_i)，</span><br><span class="line">        <span class="variable">.O</span>                              (gt0_rxusrclk_i)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> GT0_TXUSRCLK_OUT = gt0_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT0_TXUSRCLK2_OUT = gt0_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT0_RXUSRCLK_OUT = gt0_rxusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT0_RXUSRCLK2_OUT = gt0_rxusrclk_i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">assign</span> GT1_TXUSRCLK_OUT = gt0_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT1_TXUSRCLK2_OUT = gt0_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT1_RXUSRCLK_OUT = gt0_rxusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT1_RXUSRCLK2_OUT = gt0_rxusrclk_i;</span><br></pre></td></tr></table></figure><h3 id="问题定位-1"><a href="#问题定位-1" class="headerlink" title="问题定位"></a>问题定位</h3><p>因此，需要将通道1的时钟源修改回其原本的内部恢复&#x2F;发送时钟。需要增加一些两个BUFG的资源，代码如下:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Instantiate a MMCM module to divide the reference clock. Uses internal feedback</span></span><br><span class="line">    <span class="comment">// for improved jitter performance， and to avoid consuming an additional BUFG</span></span><br><span class="line"></span><br><span class="line">    BUFG txoutclk_bufg0_i0</span><br><span class="line">    (</span><br><span class="line">        <span class="variable">.I</span>                              (gt0_txoutclk_i)，</span><br><span class="line">        <span class="variable">.O</span>                              (gt0_txusrclk_i)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    BUFG rxoutclk_bufg1_i0</span><br><span class="line">    (</span><br><span class="line">        <span class="variable">.I</span>                              (gt0_rxoutclk_i)，</span><br><span class="line">        <span class="variable">.O</span>                              (gt0_rxusrclk_i)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    BUFG txoutclk_bufg0_i1</span><br><span class="line">    (</span><br><span class="line">        <span class="variable">.I</span>                              (gt1_txoutclk_i)，</span><br><span class="line">        <span class="variable">.O</span>                              (gt1_txusrclk_i)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    BUFG rxoutclk_bufg1_i1</span><br><span class="line">    (</span><br><span class="line">        <span class="variable">.I</span>                              (gt1_rxoutclk_i)，</span><br><span class="line">        <span class="variable">.O</span>                              (gt1_rxusrclk_i)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> GT0_TXUSRCLK_OUT = gt0_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT0_TXUSRCLK2_OUT = gt0_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT0_RXUSRCLK_OUT = gt0_rxusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT0_RXUSRCLK2_OUT = gt0_rxusrclk_i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">assign</span> GT1_TXUSRCLK_OUT = gt1_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT1_TXUSRCLK2_OUT = gt1_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT1_RXUSRCLK_OUT = gt1_rxusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT1_RXUSRCLK2_OUT = gt1_rxusrclk_i;</span><br></pre></td></tr></table></figure><p>修改之后，通道0与通道1的时钟域相互独立，接收数据后使用FIFO或RAM将数据同步到FPGA内部时钟域下进行进一步处理，发送也同理。</p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数字下变频(DDC)、数字上变频(DUC)</title>
      <link href="//article/DDC_DUC.html"/>
      <url>//article/DDC_DUC.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>概述了数字变频的数学原理与实际使用情况,使用Matlab仿真,先构造频域连续的宽带信号模拟基带数字信号,如果利用傅里叶反变换构造了时域信号用于仿真.文章给出了仿真代码与结果图.</p></blockquote><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在无线通信中，数据由核心网下传至基站，基站经过处理后变成电磁信号对外发送，最后到达用户端。在基站中，核心网下发的未被处理过的数字信号被称为基带信号。基带信号通常是零频宽&#x2F;窄带信号。基带信号的采样率较低，不能满足射频发射的要求，所以基带信号往往经过滤波和内插转换成高采样率，从而调制到中频载波频率上.<br>此时若基站接收到两路不同的基带信号，则无法做模拟上变频到同一频段，因为从频谱上看两个基带信号频谱叠加了，<a href="#%E9%A2%91%E8%B0%B1%E5%8F%A0%E5%8A%A0"><strong>相互干扰</strong></a>。若使用两个频段对外发送则过于浪费频谱资源了。在同一空间内，通信信道是有限的，因此需要在模拟上变频之前先做数字上变频，将两路基带信号调制到一起，成为在频谱上连续的基带信号后，做模拟上变频，调制到中高频后对外发送。这样就只会占用一条中频带，节约了无线资源。</p><blockquote><p>具体可以看这篇博客<a href="https://blog.csdn.net/HiWangWenBing/article/details/112306673">[4G&amp;5G专题-9]：RRU 数字上变频DUC与数字下变频DDC</a>。</p></blockquote><h2 id="数字上变频-DUC-数学原理"><a href="#数字上变频-DUC-数学原理" class="headerlink" title="数字上变频(DUC)数学原理"></a>数字上变频(DUC)数学原理</h2><p>数字上变频本质是是将一个处于零频的宽带信号搬移至高于零频的频段。原理上就是信号的调制，数学原理可以参考：<a href="https://blog.csdn.net/HiWangWenBing/article/details/110162546">通信系统中的调制解调</a>。</p><p>从公式上看频谱搬移可以通过时域中的信号乘以一个<a href="https://blog.csdn.net/weixin_38939826/article/details/102893656">单音信号</a>实现，公式如下:<br>$$<br>y(t) &#x3D; x(t)*cos(\omega_1t)<br>$$</p><p>其中$x(t)$为需要调制的信号，假设也为一个单音信号$sin(\omega_0t)$则:<br>$$<br>\begin{align}<br>y(t) &amp;&#x3D; sin(\omega_0t) * cos(\omega_1t) \nonumber\\<br>     &amp;&#x3D; \frac{sin(\omega_0+\omega_1)+cos(\omega_0-\omega_1)}{2} \nonumber<br>\end{align}<br>$$<br>由上可以得出频谱搬移后会出现镜像分别为$\omega_0+\omega_1$和$\omega_0-\omega_1$这两个频率上。但在基带处理中基带信号一般为<a href="https://rf.eefocus.com/article/id-335996">IQ信号</a>，因此用于调制的信号也该是个复数信号。<br>所以有</p><p>$$<br>y(t) &#x3D; x(t)*e^{j2\pi f_0 t}<br>$$</p><p>其中</p><ul><li>$x(t)$是基带信号</li><li>$e^{j2\pi f_0 t}$是复指数信号，可以看作载波信号。</li><li>$f_0$是搬移的频率，决定了搬移的幅度和方向。</li></ul><p>复指数信号的时域表达式为：</p><p>$$<br>    e^{j2\pi f_0 t} &#x3D; \cos(\omega_1t) + j \sin(\omega_1t)<br>$$</p><p>因此从时域上看:<br>$$<br>    y(t) &#x3D; x(t) * [cos(\omega_1t)+jsin(\omega_1t)]<br>$$</p><p>假设基带信号为<a href="https://blog.csdn.net/weixin_38939826/article/details/102893656">单音信号</a>,其时域上三角函数表达式为:</p><p>$$<br>    x(t)&#x3D;cos(\omega_0t)+jsin(\omega_0t)<br>$$</p><p>则时域的频谱搬移可以由下表示:<br>$$ \begin{align}<br>    y(t) &amp;&#x3D; [cos(\omega_0t)+jsin(\omega_0t)]*[cos(\omega_1t)+jsin(\omega_1t)] \nonumber\\<br>     &amp;&#x3D;[cos(\omega_0t)cos(\omega_1t)-sin(\omega_0t)sin(\omega_1t)]+j[cos(\omega_0t)sin(\omega_1t)+sin(\omega_0t)cos(\omega_1t)] \nonumber\\<br>     &amp;&#x3D;cos[(\omega_0+\omega_1)t]+jsin[(\omega_0+\omega_1)t] \nonumber<br>\end{align}<br>$$<br>由上面的计算可以看出原信号被搬移到了$\omega_0+\omega_1$上，若想得到位于$\omega_0-\omega_1$的信号则对IQ信号做差运算即可因为在FPGA中基带信号的实部和虚部是存在不同的变量中，可以单独拿出来做运算。复数在变换完成后可以只留下一个频率，这对我们基带处理带来了很大的便利。</p><h2 id="Matlab模拟"><a href="#Matlab模拟" class="headerlink" title="Matlab模拟"></a>Matlab模拟</h2><h3 id="建立基带时域信号"><a href="#建立基带时域信号" class="headerlink" title="建立基带时域信号"></a>建立基带时域信号</h3><p>基带信号一般为零频的宽带或窄带信号，一开始的想法是利用不同频率的正弦波时域叠加构造宽带信号，但是傅里叶变换以后的叠加信号在频域上不连续。于是我反着来，先构建连续的频谱，然后用傅里叶反变换得到时域信号。</p><p>首先创建一个长度为$N$的全0行向量,然后将带宽内的元素全部赋值为1.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spectrum = <span class="built_in">zeros</span>(<span class="number">1</span>, N);</span><br><span class="line">spectrum(f &lt;= bandwidth) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>我们得到了一个在索引值小于bandwidth时值全为1的行向量，可以认定为信号频谱。于是可以构建两个这样的不同带宽的频谱如下图:</p><p><img src="/images/%E5%AE%BD%E5%B8%A6%E4%BF%A1%E5%8F%B7.svg" alt="宽带信号"></p><p>接着为了得到时域信号我们对其做傅里叶反变换，然后再做傅里叶变换得到时域信号的频谱(觉得麻烦这步可以省略):</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal = ifft(spectrum);</span><br><span class="line">signal_fft  = fft(signal);</span><br></pre></td></tr></table></figure><p>做傅里叶变换后，在高频会出现镜像，我们舍弃掉高频的部分的数据只讨论基带信号本身。<br>然后将代码简单假工一下做成函数方便一会调用。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">broadband</span><span class="params">(varargin)</span></span></span><br><span class="line">    p = inputParser;            <span class="comment">% 函数的输入解析器</span></span><br><span class="line">    p.addParameter(<span class="string">&#x27;fs&#x27;</span>,<span class="number">1000</span>);  <span class="comment">% 设置变量名和默认参数</span></span><br><span class="line">    p.addParameter(<span class="string">&#x27;T&#x27;</span>,<span class="number">1</span>);      <span class="comment">% 设置变量名和默认参数</span></span><br><span class="line">    p.addParameter(<span class="string">&#x27;bandwidth&#x27;</span>,<span class="number">50</span>);      <span class="comment">% 设置变量名和默认参数</span></span><br><span class="line">    p.parse(varargin&#123;:&#125;);       <span class="comment">% 对输入变量进行解析，如果检测到前面的变量被赋值，则更新变量取值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 生成频谱</span></span><br><span class="line">    N = p.Results.fs*p.Results.T; <span class="comment">% 信号长度</span></span><br><span class="line">    f = <span class="built_in">linspace</span>(<span class="number">0</span>, p.Results.fs, N); <span class="comment">% 频率范围</span></span><br><span class="line">    spectrum = <span class="built_in">zeros</span>(<span class="number">1</span>, N);</span><br><span class="line">    spectrum(f &lt;= p.Results.bandwidth) = <span class="number">1</span>; <span class="comment">% 在带宽内设置频谱幅度为1</span></span><br><span class="line">    <span class="comment">% 生成时域信号</span></span><br><span class="line">    signal = ifft(spectrum);</span><br><span class="line">    <span class="comment">%傅里叶变换</span></span><br><span class="line">    signal_fft  = fft(signal);</span><br><span class="line"></span><br><span class="line">    y.fft = signal_fft(<span class="number">1</span>:<span class="keyword">end</span>/<span class="number">2</span>);</span><br><span class="line">    y.f=f(<span class="number">1</span>:<span class="keyword">end</span>/<span class="number">2</span>);</span><br><span class="line">    y.<span class="built_in">real</span> = signal;</span><br><span class="line">    y.t=<span class="built_in">linspace</span>(<span class="number">0</span>, p.Results.T, N);</span><br><span class="line">    y.n=N;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="建立载波时域信号"><a href="#建立载波时域信号" class="headerlink" title="建立载波时域信号"></a>建立载波时域信号</h3><p>直接生成特定频率的正弦波即可，注意为了一会与基带信号进行运算，要保证生成的信号长度与基带信号相同。函数代码如下</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">wave_init</span><span class="params">(varargin)</span></span></span><br><span class="line">    p = inputParser;            <span class="comment">% 函数的输入解析器</span></span><br><span class="line">    p.addParameter(<span class="string">&#x27;fs&#x27;</span>,<span class="number">1000</span>);  <span class="comment">% 设置变量名和默认参数</span></span><br><span class="line">    p.addParameter(<span class="string">&#x27;L&#x27;</span>,<span class="number">1000</span>);      <span class="comment">% 设置变量名和默认参数</span></span><br><span class="line">    p.addParameter(<span class="string">&#x27;a1&#x27;</span>,<span class="number">0</span>);      <span class="comment">% 设置变量名和默认参数</span></span><br><span class="line">    p.addParameter(<span class="string">&#x27;f1&#x27;</span>,<span class="number">0</span>);      <span class="comment">% 设置变量名和默认参数</span></span><br><span class="line">    p.parse(varargin&#123;:&#125;);       <span class="comment">% 对输入变量进行解析，如果检测到前面的变量被赋值，则更新变量取值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 定义参数</span></span><br><span class="line">    T = <span class="number">1</span>/p.Results.fs;               <span class="comment">% 采样间隔</span></span><br><span class="line">    t = (<span class="number">0</span>:p.Results.L<span class="number">-1</span>)*T;          <span class="comment">% 时间向量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 生成正弦波信号</span></span><br><span class="line">    reslut = p.Results.a1*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*p.Results.f1*t);</span><br><span class="line">    temp_fft=<span class="built_in">abs</span>(fft(reslut)); </span><br><span class="line">    f = <span class="built_in">linspace</span>(<span class="number">0</span>, p.Results.fs, p.Results.L); <span class="comment">% 频率范围</span></span><br><span class="line"></span><br><span class="line">    y.fft = temp_fft(<span class="number">1</span>:<span class="keyword">end</span>/<span class="number">2</span>);</span><br><span class="line">    y.f = f(<span class="number">1</span>:<span class="keyword">end</span>/<span class="number">2</span>);</span><br><span class="line">    y.<span class="built_in">real</span> = reslut;</span><br><span class="line">    y.t = t;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>值得注意，这里是直接使用正弦信号进行快速傅里叶变换，傅里叶变换会将信号从时域转换到频域，得到频谱。频谱是一个复数，包含幅度和相位信息。取绝对值操作后，我们得到了频谱的幅度，这表示了在不同频率下信号的能量分布情况，当然也可以直接对信号进行平方运算，我们就可以的得到信号在频域上的能量分布情况，对信号的功率谱密度进行分析。利用以上函数构造两个频率为100Hz和130Hz的载波信号。</p><h3 id="频谱搬移"><a href="#频谱搬移" class="headerlink" title="频谱搬移"></a>频谱搬移</h3><p>根据前文的计算，想要实现频谱搬移需要将基带信号与载波信号相乘。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 宽带信号</span></span><br><span class="line">wave_0 = broadband(<span class="string">&#x27;fs&#x27;</span>,<span class="number">1000</span>,<span class="string">&#x27;T&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;bandwidth&#x27;</span>,<span class="number">30</span>);</span><br><span class="line">wave_1 = broadband(<span class="string">&#x27;fs&#x27;</span>,<span class="number">1000</span>,<span class="string">&#x27;T&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;bandwidth&#x27;</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%载波信号</span></span><br><span class="line">c_wave = wave_init(<span class="string">&#x27;a1&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;f1&#x27;</span>,<span class="number">100</span>);</span><br><span class="line">c_wave_1 = wave_init(<span class="string">&#x27;a1&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;f1&#x27;</span>,<span class="number">130</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 搬移</span></span><br><span class="line">s_wave = c_wave.<span class="built_in">real</span>.*wave_0.<span class="built_in">real</span>;</span><br><span class="line">s_wave_fft = <span class="built_in">abs</span>(fft(s_wave));</span><br><span class="line"></span><br><span class="line">s_wave_1 = c_wave_1.<span class="built_in">real</span>.*wave_1.<span class="built_in">real</span>;</span><br><span class="line">s_wave_fft_1 = <span class="built_in">abs</span>(fft(s_wave_1));</span><br></pre></td></tr></table></figure><p>随后我们再将调制波时域上相加，即可得到一个宽带信号。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wave = s_wave + s_wave_1;</span><br><span class="line">wave_fft = <span class="built_in">abs</span>(fft(wave));</span><br></pre></td></tr></table></figure><p>若不进行搬移直接叠加会发生干扰，信号无法解调，如图:<a id="频谱叠加"></a></p><p>这是主函数调试代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 宽带信号</span></span><br><span class="line">wave_0 = broadband(<span class="string">&#x27;fs&#x27;</span>,<span class="number">1000</span>,<span class="string">&#x27;T&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;bandwidth&#x27;</span>,<span class="number">30</span>);</span><br><span class="line">wave_1 = broadband(<span class="string">&#x27;fs&#x27;</span>,<span class="number">1000</span>,<span class="string">&#x27;T&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;bandwidth&#x27;</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%载波信号</span></span><br><span class="line">c_wave = wave_init(<span class="string">&#x27;a1&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;f1&#x27;</span>,<span class="number">100</span>);</span><br><span class="line">c_wave_1 = wave_init(<span class="string">&#x27;a1&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;f1&#x27;</span>,<span class="number">130</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 搬移</span></span><br><span class="line">s_wave = c_wave.<span class="built_in">real</span>.*wave_0.<span class="built_in">real</span>;</span><br><span class="line">s_wave_fft = <span class="built_in">abs</span>(fft(s_wave));</span><br><span class="line"></span><br><span class="line">s_wave_1 = c_wave_1.<span class="built_in">real</span>.*wave_1.<span class="built_in">real</span>;</span><br><span class="line">s_wave_fft_1 = <span class="built_in">abs</span>(fft(s_wave_1));</span><br><span class="line"></span><br><span class="line">wave = s_wave + s_wave_1;</span><br><span class="line">wave_fft = <span class="built_in">abs</span>(fft(wave));</span><br><span class="line"></span><br><span class="line"><span class="comment">% s_wave_2 = wave_0.real + wave_1.real;</span></span><br><span class="line"><span class="comment">% s_wave_2_fft = abs(fft(s_wave_2));</span></span><br><span class="line"><span class="comment">% subplot(1,1,1);</span></span><br><span class="line"><span class="comment">% plot(wave_0.f, s_wave_2_fft(1:end/2));</span></span><br><span class="line"><span class="comment">% title(&quot;叠加频谱&quot;);</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(wave_0.f, wave_0.fft);</span><br><span class="line">title(<span class="string">&quot;信号α频谱&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">% subplot(2,1,2);</span></span><br><span class="line"><span class="built_in">plot</span>(wave_1.f, wave_1.fft);</span><br><span class="line">title(<span class="string">&quot;信号β频谱&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(c_wave.f, c_wave.fft);</span><br><span class="line">title(<span class="string">&quot;载波频谱i&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">plot</span>(c_wave.f, c_wave_1.fft);</span><br><span class="line">title(<span class="string">&quot;载波频谱ii&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">plot</span>(c_wave.f, s_wave_fft(<span class="number">1</span>:<span class="keyword">end</span>/<span class="number">2</span>));</span><br><span class="line">title(<span class="string">&quot;调制波(α*i)频谱&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">plot</span>(c_wave.f, s_wave_fft_1(<span class="number">1</span>:<span class="keyword">end</span>/<span class="number">2</span>));</span><br><span class="line">title(<span class="string">&quot;调制波(β*ii)频谱&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">7</span>,<span class="number">1</span>,<span class="number">7</span>);</span><br><span class="line"><span class="built_in">plot</span>(c_wave.f, wave_fft(<span class="number">1</span>:<span class="keyword">end</span>/<span class="number">2</span>));</span><br><span class="line">title(<span class="string">&quot;调制波叠加((α*i)+(β*ii))频谱&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ViVado报错记录及解决方式</title>
      <link href="//article/Vivado_Log_Resolution.html"/>
      <url>//article/Vivado_Log_Resolution.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="Generate-Bitstream-Failed"><a href="#Generate-Bitstream-Failed" class="headerlink" title="Generate Bitstream Failed"></a><center>Generate Bitstream Failed</center></h2><h3 id="DRC-NSTD-1"><a href="#DRC-NSTD-1" class="headerlink" title="[DRC NSTD-1]"></a>[DRC NSTD-1]</h3><ul><li><p><strong>问题</strong><br>引脚定义了，没有使用或者没做物理约束导致生成bit文件报错，DRC电气检测失败。此处特指顶层文件输入输出引脚。</p></li><li><p><strong>解决</strong></p><p>  1.找到未使用引脚并注释。</p><p>  2.使用TCL文件忽略该项报错,TCL文件内容如下，手动创建该文件后，在Vivado右栏选择Setting-&gt;Project Settings-&gt;Implementation-&gt;Write Bitstream-&gt;tcl.pre选择该文件并导入后重新执行Generate Bitstream。</p><p>  3.给引脚添加物理约束</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_property SEVERITY &#123;Warning&#125; [get_drc_checks NSTD<span class="number">-1</span>]</span><br><span class="line">set_property SEVERITY &#123;Warning&#125; [get_drc_checks UCIO<span class="number">-1</span>]</span><br><span class="line">set_property SEVERITY &#123;Warning&#125; [get_drc_checks RTSTAT<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="Run-Implementation-Failed"><a href="#Run-Implementation-Failed" class="headerlink" title="Run Implementation Failed"></a><center>Run Implementation Failed</center></h2><h3 id="Place-30-494"><a href="#Place-30-494" class="headerlink" title="[Place 30-494]"></a>[Place 30-494]</h3><blockquote><p>[Place 30-494] The design is empty Resolution: Check if opt_design has removed all the leaf cells of your design.  Check whether you have instantiated and connected all of the top level ports.</p></blockquote><ul><li><p><strong>问题</strong><br>顶层文件没有输出引脚整个电路逻辑会被Vivado优化掉。</p></li><li><p><strong>解决</strong><br>随便定义一个引脚物理约束一下就可以解决。</p></li></ul><h3 id="DRC-UTLZ-1"><a href="#DRC-UTLZ-1" class="headerlink" title="[DRC UTLZ-1]"></a>[DRC UTLZ-1]</h3><blockquote><p>Resource utilization: DSP48E1 over-utilized in Top Level Design (This design requires more DSP48E1 cells than are available in the target device. This design requires 1211 of such cell types but only 900 compatible sites are available in the target device. Please analyze your synthesis results and constraints to ensure the design is mapped to Xilinx primitives as expected. If so, please consider targeting a larger device.)</p></blockquote><ul><li><p><strong>问题</strong><br>提示很明显指出,DSP资源不足.</p></li><li><p><strong>解决</strong><br>点击 Open Synthesized Design -&gt; Report Utilization 查看各个模块DSP使用情况,优化DSP使用.一般需要关注DDS,FIR,CFR等模块.</p></li></ul><blockquote><p>Resource utilization: BUFG over-utilized in Top Level Design (This design requires more BUFG cells than are available in the target device. This design requires 33 of such cell types but only 32 compatible sites are available in the target device. Please analyze your synthesis results and constraints to ensure the design is mapped to Xilinx primitives as expected. If so, please consider targeting a larger device.)</p></blockquote><ul><li><p><strong>问题</strong><br>提示很明显指出,BUFG资源不足.</p></li><li><p><strong>解决</strong><br>某个项目中发现BUFG资源不足,编译后打开 Open Synthesized Design -&gt; Report Utilization 查看 BUFGCTRL项目,括号中的数字表示该型号器件最大可用资源数量,查看各个模块使用量合理优化即可</p></li></ul><h3 id="DRC-BIVC-1"><a href="#DRC-BIVC-1" class="headerlink" title="[DRC BIVC-1]"></a>[DRC BIVC-1]</h3><blockquote><p>ERROR: [DRC BIVC-1]  Bank IO standard Vcc: Conflicting Vcc voltages in bank 10. For example, the following two ports in this bank have conflicting VCCOs:xxxx[0] (LVCMOS18, requiring VCCO&#x3D;1.800) and xxxxx (LVCMOS33, requiring VCCO&#x3D;3.300)</p></blockquote><ul><li><p><strong>问题</strong><br>电气检测提示，在Bank10中出现了两种电平标准，这是不允许的。Xilinx FPGA将引脚划分为多个Bank以适应不同电压,但是在同一个Bank内只能存在一种电平标准。</p></li><li><p><strong>解决</strong><br>根据提示检查bank内引脚电平标准，修改电平标准或电路。<br>查看Io所属bank可以通过进入<a href="https://www.xilinx.com/support/package-pinout-files.html">AMD XILINX Package Files Portal</a>，选择自己对应的器件型号进行查看。</p><p>Xilinx FPGA主要有两种类型Bank</p><ul><li>HP(High-performance) BANK</li><li>HR(High-range)BANK</li></ul><p>其中HR BANK拥有更为广泛的电平标准，最高支持3.3V高电平。而HP BANK最高支持1.8V，主要是高速通信信号设计使用。</p></li></ul><hr><h2 id="Run-Synthesis-Failed"><a href="#Run-Synthesis-Failed" class="headerlink" title="Run Synthesis Failed"></a><center>Run Synthesis Failed</center></h2><h3 id="Synth-8-91"><a href="#Synth-8-91" class="headerlink" title="[Synth 8-91]"></a>[Synth 8-91]</h3><blockquote><p>ambiguous clock in event control</p></blockquote><ul><li><p><strong>问题</strong><br>敏感信号没有被使用</p></li><li><p><strong>解决</strong><br>使用敏感信号或删除敏感信号</p></li></ul><h3 id="Synth-8-5535"><a href="#Synth-8-5535" class="headerlink" title="[Synth 8-5535]"></a>[Synth 8-5535]</h3><blockquote><p>port <sys_clk> has illegal connections. It is illegal to have a port connected to an input buffer and other components. The following are the port connections : Input Buffer: Port I of instance clkin1_ibufg(IBUF) in module <clk_wiz_0_clk_wiz> Other Components: Port C of instance sys_rst_n_reg(FD) in module ddr3_rw_top</p></blockquote><ul><li><p><strong>问题</strong><br>顶层时钟引脚未经过IBUF直接使用会导致此错误</p></li><li><p><strong>解决</strong><br>  使用<code>IBUF</code>和<code>BUFG</code>原语将时钟导入输入时钟缓冲和全局时钟缓冲后使用。<code>IBUFG</code>即输入全局缓冲，是与专用全局时钟输入管脚相连接的首级全局缓冲。所有从全局时钟管脚输入的信号必须经过IBUF元，否则在布局布线时会报错。 IBUFG支持AGP、CTT、GTL、GTLP、HSTL、LVCMOS、LVDCI、LVDS、LVPECL、LVTTL、PCI、PCIX和 SSTL等多种格式的IO标准。<code>BUFG</code><br>  是全局缓冲，它的输入是IBUFG的输出，BUFG的输出到达FPGA内部的IOB、CLB、选择性块RAM的时钟延迟和抖动最小。</p></li></ul><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a><center>Others</center></h2><h3 id="DRC-AVAL-326"><a href="#DRC-AVAL-326" class="headerlink" title="[DRC AVAL-326]"></a>[DRC AVAL-326]</h3><blockquote><p>Hard_block_must_have_LOC: The hard block IBUFDS_GTE4 cell xxxxxxxxxxxxxxxxx.ibufds_gtex_i is missing a valid LOC constraint for placement assignment, normally supplied by IP generation or manually assigned using the LOC property. Unguided placement of this block may cause problems in routing or other issues. Please check your design and set a valid LOC for this block to avoid these problems.</p></blockquote><ul><li><strong>问题</strong><br>GTX管脚放置错误</li><li><strong>解决</strong><br>检查是否将普通信号约束到了GTX差分时钟引脚上,或者GTX引脚约束到了普通引脚上。想要知道是否是专用引脚可以通过<a href="https://www.xilinx.com/support/package-pinout-files.html">AMD XILINX Package Files Portal</a>选择自己的器件进行查询，I&#x2F;O Type栏若为GTX则为专用引脚，此时需要修改约束文件更换物理约束。<br>若无以上问题，检查前面关于GTX的警告，若有相关警告则需要优先解决。</li></ul><h3 id="USF-XSim-62"><a href="#USF-XSim-62" class="headerlink" title="[USF-XSim-62]"></a>[USF-XSim-62]</h3><blockquote><p>‘compile’ step failed with error(s). Please check the Tcl console output or ‘&#x2F;xxxx&#x2F;xxx&#x2F;xxxx&#x2F;xxxxxx.sim&#x2F;sim_1&#x2F;behav&#x2F;xsim&#x2F;xvlog.log’ file for more information.</p></blockquote><ul><li><strong>问题</strong><br>行为仿真出现错误,大概率是语法错误，打开提示中指定的<code>xvlog.log</code>文件或查看Tcl控制台即可查看错误。</li><li><strong>解决</strong><br>根据<code>xvlog.log</code>详细提示解决问题。若已经解决且编译通过还显示此提示，选择此条提示-&gt;右键-&gt;Discard User Created Messages然后重新编译即可。</li></ul><h3 id="Unable-to-open-file-because-the-path-is-invalid"><a href="#Unable-to-open-file-because-the-path-is-invalid" class="headerlink" title="Unable to open file &lt;file&gt; because the path is invalid"></a>Unable to open file &lt;file&gt; because the path is invalid</h3><ul><li><strong>问题</strong><br>突然发现文件无法打开，但使用Vscode可以在路径下找到文件，且使用Vivado GUI可以打开文件。该文件存在，但无法通过Messages栏打开。</li><li><strong>解决</strong><br>打开..&#x2F;projectName.runs&#x2F;synth_1&#x2F;runme.log文件，这个是编译日志，Message栏的信息就是由这个文件生成。观察日志，发现项目名称中出现了纯数字，猜测Vivado无法识别纯数字路径。修改掉路径，重新编译，该错误解决。</li></ul>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
          <category> Vivado </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS</title>
      <link href="//article/FreeRTOS.html"/>
      <url>//article/FreeRTOS.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>FreeRTOS学习日志,由于工作原因,目前这棵技能树不作为主要发展方向了,该类型博客无限期停更…</p></blockquote><span id="more"></span><h2 id="1-关于-osThreadNew"><a href="#1-关于-osThreadNew" class="headerlink" title="1.关于 osThreadNew ()"></a>1.关于 osThreadNew ()</h2><h3 id="1-1-FreeRTOS线程与任务的关系"><a href="#1-1-FreeRTOS线程与任务的关系" class="headerlink" title="1.1 FreeRTOS线程与任务的关系"></a>1.1 FreeRTOS线程与任务的关系</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">osThreadId_t <span class="title function_">osThreadNew</span> <span class="params">(osThreadFunc_t func, </span></span><br><span class="line"><span class="params">  <span class="type">void</span> *argument, </span></span><br><span class="line"><span class="params">  <span class="type">const</span> osThreadAttr_t *attr)</span></span><br><span class="line"><span class="comment">/*******************************没有感情的分界线********************/</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">(TaskFunction_t pxTaskCode,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,</span></span><br><span class="line"><span class="params"><span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth,</span></span><br><span class="line"><span class="params"><span class="type">void</span> * <span class="type">const</span> pvParameters,</span></span><br><span class="line"><span class="params">UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span></span><br><span class="line">TaskHandle_t <span class="title function_">xTaskCreateStatic</span><span class="params">(TaskFunction_t pxTaskCode,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,</span></span><br><span class="line"><span class="params"><span class="type">void</span> * <span class="type">const</span> pvParameters,</span></span><br><span class="line"><span class="params">UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">StackType_t * <span class="type">const</span> puxStackBuffer,</span></span><br><span class="line"><span class="params">StaticTask_t * <span class="type">const</span> pxTaskBuffer )</span></span><br></pre></td></tr></table></figure><p>先后分别是CMSIS-OS和FreeRTOS提供的任务创建API，函数名给我带来了一个疑问<strong>线程和任务之间的关系</strong>，翻阅资料后找到如下解释。</p><blockquote><p>在多数通用（分时）操作系统（如Linux，Windows）中，进程是系统资源分配的最小单位，线程为CPU调度的最小单元。而在实时操作系统中，多数情况下不区分线程与进程进行独立管理，为了减小系统资源占用以及提高实时性，往往将线程与进程合二为一，采用任务（一个个独立且无法返回的函数）作为应用程序的最小调度运行单元，使用TCB（任务控制块）对任务进行管理，FreeRTOS即是如此。<br>    结论：像FreeRTOS这样的轻量级OS，其中的任务与线程的含义一致，即在FreeRTOS上跑的整个程序即为一个进程，该进程中又包含着多个线程（任务），这些线程有些是系统自动创建的，有些为用户手动创建。<br>                                                    <a href="https://blog.csdn.net/weixin_48206270/article/details/124102544">原文链接</a></p></blockquote><p><strong>翻阅ST提供的用户手册得到如下信息。</strong></p><blockquote><p>本用户手册的目标读者为在 STM32 微控制器上使用 STM32Cube 固件的开发者。它完整描述了如何使用具有实时操作系统 （RTOS）的 STM32Cube 固件组件；本用户手册还提供了一组示例说明，它们基于 FreeRTOS，使用 CMSIS-OS 封装层提供的通用 API。<br> 在 STM32Cube 固件中，通过 ARM 提供的通用 CMSIS-OS 封装层，FreeRTOS 用作实时操作系统。使用 FreeRTOS 的样例和应用可直接移植到其它任何 RTOS 而不需要修改高层API，在此情况下仅需更改 CMSIS-OS 封装。</p></blockquote><ul><li>   <strong>结论:osThreadNew()是ARM的CMSIS-OS的封装层API，内部包含了FreeRTOS的<br>   动态任务创建xTaskCreate()<br>   静态任务创建xTaskCreateStatic()<br>   根据参数选择选择调用动态还是静态创建，具体实现后文给出。</strong></li></ul><h3 id="1-2-osThreadNew"><a href="#1-2-osThreadNew" class="headerlink" title="1.2 osThreadNew ()"></a>1.2 osThreadNew ()</h3><h4 id="1-2-1-osThreadNew-如何实现动态创建与静态创建的选择"><a href="#1-2-1-osThreadNew-如何实现动态创建与静态创建的选择" class="headerlink" title="1.2.1 osThreadNew ()如何实现动态创建与静态创建的选择"></a>1.2.1 osThreadNew ()如何实现动态创建与静态创建的选择</h4><p>从前文已知osThreadNew()是ARM提供的上层封装，那么具体是如何实现动态与静态的选择。<br>翻阅源码发现原理在于其参数的选择，一下给出源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">osThreadId_t <span class="title function_">osThreadNew</span> <span class="params">(osThreadFunc_t func, <span class="type">void</span> *argument, <span class="type">const</span> osThreadAttr_t *attr)</span> &#123;</span><br><span class="line">  <span class="type">char</span> empty;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">uint32_t</span> <span class="built_in">stack</span>;</span><br><span class="line">  TaskHandle_t hTask;</span><br><span class="line">  UBaseType_t prio;</span><br><span class="line">  <span class="type">int32_t</span> mem;</span><br><span class="line"></span><br><span class="line">  hTask = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!IS_IRQ() &amp;&amp; (func != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="built_in">stack</span> = configMINIMAL_STACK_SIZE;</span><br><span class="line">    prio  = (UBaseType_t)osPriorityNormal;</span><br><span class="line"></span><br><span class="line">    empty = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    name  = &amp;empty;</span><br><span class="line">    mem   = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (attr-&gt;name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        name = attr-&gt;name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (attr-&gt;priority != osPriorityNone) &#123;</span><br><span class="line">        prio = (UBaseType_t)attr-&gt;priority;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((prio &lt; osPriorityIdle) || (prio &gt; osPriorityISR) || ((attr-&gt;attr_bits &amp; osThreadJoinable) == osThreadJoinable)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (attr-&gt;stack_size &gt; <span class="number">0U</span>) &#123;</span><br><span class="line">        <span class="comment">/* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */</span></span><br><span class="line">        <span class="comment">/* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */</span></span><br><span class="line">        <span class="built_in">stack</span> = attr-&gt;stack_size / <span class="keyword">sizeof</span>(StackType_t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((attr-&gt;cb_mem    != <span class="literal">NULL</span>) &amp;&amp; (attr-&gt;cb_size    &gt;= <span class="keyword">sizeof</span>(StaticTask_t)) &amp;&amp;</span><br><span class="line">          (attr-&gt;stack_mem != <span class="literal">NULL</span>) &amp;&amp; (attr-&gt;stack_size &gt;  <span class="number">0U</span>)) &#123;</span><br><span class="line">        mem = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((attr-&gt;cb_mem == <span class="literal">NULL</span>) &amp;&amp; (attr-&gt;cb_size == <span class="number">0U</span>) &amp;&amp; (attr-&gt;stack_mem == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">          mem = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      mem = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">1</span>) &#123;</span><br><span class="line">      hTask = xTaskCreateStatic ((TaskFunction_t)func, name, <span class="built_in">stack</span>, argument, prio, (StackType_t  *)attr-&gt;stack_mem,</span><br><span class="line">                                                                                    (StaticTask_t *)attr-&gt;cb_mem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xTaskCreate ((TaskFunction_t)func, name, (<span class="type">uint16_t</span>)<span class="built_in">stack</span>, argument, prio, &amp;hTask) != pdPASS) &#123;</span><br><span class="line">          hTask = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((osThreadId_t)hTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在末尾可以看出使用哪一种创建方式由参数<code>mem</code>决定，阅读前文发现只有</p><ul><li>当<code>attr-&gt;stack_mem</code>有值且指定用户数组以及任务控制块地址时的时候会使得<code>mem</code>置1，此时调用的时静态创建任务函数。</li><li>当<code>attr-&gt;stack_mem</code>没有值的时候会使得<code>mem</code>置0，此时调用的时动态创建任务函数。</li></ul></li><li><p>而<code>attr-&gt;stack_mem</code>的值是由<code>const osThreadAttr_t *attr</code>形参结构体中取得，在创建任务的时候需要定义一个结构体作为参数传入osThreadNew()中，CubeMX给出的默认任务参数如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">osThreadId_t startTaskHandle;</span><br><span class="line"><span class="type">const</span> osThreadAttr_t startTask_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;startTask&quot;</span>,</span><br><span class="line">  .stack_size = <span class="number">128</span> * <span class="number">4</span>,  <span class="comment">//0.5KB</span></span><br><span class="line">  .priority = (osPriority_t) osPriorityLow3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>必须同时给出任务栈大小，任务堆栈，任务控制块地址才能调用静态创建任务函数，否则只取<code>attr-&gt;stack_mem</code>的值作为任务栈大小动态创建任务。若连<code>attr-&gt;stack_mem</code>都未给出，则取系统默认设置为任务栈大小动态创建任务。</p></li></ul><h4 id="1-2-2-xTaskCreate-任务栈空间理解"><a href="#1-2-2-xTaskCreate-任务栈空间理解" class="headerlink" title="1.2.2 xTaskCreate()任务栈空间理解"></a>1.2.2 xTaskCreate()任务栈空间理解</h4><p>在阅读动态创建函数传参时候发现，居然也有任务栈空间这一项参数，而我记得我阅读操作手册的时候写的是动态任务创建任务栈空间由操作系统分配，归操作系统管理，那么为什么还要传这一个参数呢。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xTaskCreate ((TaskFunction_t)func, name, (<span class="type">uint16_t</span>)<span class="built_in">stack</span>, argument, prio, &amp;hTask) </span><br></pre></td></tr></table></figure><p>回去重新阅读了操作手册发现自己理解错误，以下贴出操作手册原文。</p><blockquote><p>每个任务都需要 RAM 来保存任务状态，并由任务用作其堆栈。 如果使用 xTaskCreate() 创建任务，则所需的 RAM 将自动 从 FreeRTOS 堆中分配。 如果创建任务 使用了 xTaskCreateStatic()，则 RAM 由应用程序编写者提供，因此可以在编译时进行静态分配。</p></blockquote><ul><li>在<strong>动态创建</strong>任务时也是<strong>需要指定任务栈空间</strong>的，但此时任务栈空间是由操作系统从<strong>自己管理的堆</strong>中分配的，管理权归操作系统。</li><li>在<strong>静态创建</strong>任务时候，指定的任务栈空间是由用户自己提供的，而占用的空间是在RAM中除去RTOS所管理的堆剩下的空间中提供的，所以不由RTOS管理。</li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00125.html">这里给出FreeRTOS官网开发者手册关于xTaskCreate描述的地址</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/Static_Vs_Dynamic_Memory_Allocation.html">这里给出FreeRTOS官网开发者手册关于静态与动态创建任务描述的地址</a></li></ul><p><strong>所以实际上动态创建任务也是需要指定任务栈空间的，但是我们创建时并没有给出参数，他又是传了什么进去呢？</strong></p><p>阅读上文源码发现，该参数一开始就被赋值了<br><code>stack = configMINIMAL_STACK_SIZE</code><br>其中<br><code>configMINIMAL_STACK_SIZE</code><br>是个宏定义，我们在<em>FreeRTOSConfig.h</em>文件中找到了定义<br><code>#define configMINIMAL_STACK_SIZE                 ((uint16_t)128)</code></p><ul><li>也就是说当我们不指定任务栈空间，CMSIS-OS提供的封装帮我自动设置了任务栈空间，并且调用动态创建任务函数。</li></ul><h4 id="1-2-3-CMSIS-OS与FreeRTOS任务栈空间单位不同！"><a href="#1-2-3-CMSIS-OS与FreeRTOS任务栈空间单位不同！" class="headerlink" title="1.2.3 CMSIS-OS与FreeRTOS任务栈空间单位不同！"></a>1.2.3 CMSIS-OS与FreeRTOS任务栈空间单位不同！</h4><p>接下来我遇到了最坑的一个点，如题所说，CMSIS-OS与FreeRTOS任务栈空间单位不同。</p><ul><li>在学习FreeRTOS时我观看了<em>正点原子</em>的视频，包括在网上搜索的资料都是面向FreeRTOS的。而FreeRTOS提供的创建任务函数中指定任务栈大小的参数<code>stack</code>其单位是<strong>字</strong>。<blockquote><p>在stm32中，1字&#x3D;4字节     1字节&#x3D;8位</p></blockquote></li></ul><p>所以，我理所当然（我大意了）的认为<code>osThreadNew()</code>参数中的<code>stack_size </code>其单位也是字，所以在计算的时候一直当作字来计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> osThreadAttr_t startTask_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;startTask&quot;</span>,</span><br><span class="line">  .stack_size = <span class="number">128</span> * <span class="number">4</span>,</span><br><span class="line">  .priority = (osPriority_t) osPriorityLow3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并且，在这个函数中的注释写了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */</span></span><br><span class="line"><span class="comment">/* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */</span></span><br><span class="line">翻译过来就是</span><br><span class="line"><span class="comment">/*在FreeRTOS中，堆栈不是以字节为单位，而是以sizeof（StackType_t）为单位，在ARM端口上为4*/</span></span><br><span class="line"><span class="comment">/*因此，堆栈大小应为4字节对齐，以避免除法造成的副作用*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 但当我调试时候计算栈空间时发现不太对劲，具体怎么发现的我就不说了，反正不是很聪明的样子。贴个调试图。<br> <img src="https://img-blog.csdnimg.cn/f29e34a84c094b03842a3e6e19082770.png" alt="在这里插入图片描述"><br>在和老学长一番争论，并且重新翻阅源码以及用户手册后我突然发现在注释的前后写了一段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (attr-&gt;stack_size &gt; <span class="number">0U</span>) &#123;</span><br><span class="line">  <span class="comment">/* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */</span></span><br><span class="line">  <span class="comment">/* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */</span></span><br><span class="line">  <span class="built_in">stack</span> = attr-&gt;stack_size / <span class="keyword">sizeof</span>(StackType_t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他把我传进去的参数除了一个<code>StackType_t</code>大小。<br>查阅其定义发现<br><code>typedef portSTACK_TYPE StackType_t;</code><br><code>#define portSTACK_TYPEuint32_t</code></p><blockquote><p>这个类型大小32位，8位1字节，也就4个字节，1个字。<br><code>sizeof()</code>用于返回运算对象的内存大小，单位是字节。<br>所以<code>sizeof(StackType_t)=4</code></p></blockquote><ul><li>也就是说在<code>osThreadNew()</code>的任务栈空间参数在经过ARM封装后实际上是以“字节”为单位的，所以也就是说我我传进来的数字实际上是 <code>128 * 4=512字节/4=128字</code>赋给了<code>stack </code>。</li></ul><p>这里贴出官网对参数<code>usStackDepth  </code>也就是<code>stack </code>赋给的形参值的介绍与地址。<a href="https://www.freertos.org/zh-cn-cmn-s/a00125.html">用户手册参数介绍地址</a></p><blockquote><p>要分配用于 任务堆栈的 字数（不是字节）。例如，如果堆栈的宽度为 16 位，usStackDepth 为 100，则将分配 200 字节用作该任务的堆栈。 再举一例，如果堆栈的宽度为 32 位，usStackDepth 为 400，则将分配 1600 字节用作该任务的堆栈。<br>堆栈深度与堆栈宽度的乘积不得超过 size_t 类型变量所能包含的最大值。</p></blockquote><h4 id="1-2-4-选择动态分配时osThreadNew-分配的任务栈空间"><a href="#1-2-4-选择动态分配时osThreadNew-分配的任务栈空间" class="headerlink" title="1.2.4 选择动态分配时osThreadNew()分配的任务栈空间"></a>1.2.4 选择动态分配时osThreadNew()分配的任务栈空间</h4><p>这个比较好找，直接阅读源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">osThreadId_t <span class="title function_">osThreadNew</span> <span class="params">(osThreadFunc_t func, <span class="type">void</span> *argument, <span class="type">const</span> osThreadAttr_t *attr)</span> &#123;</span><br><span class="line">  <span class="type">char</span> empty;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">uint32_t</span> <span class="built_in">stack</span>;</span><br><span class="line">  TaskHandle_t hTask;</span><br><span class="line">  UBaseType_t prio;</span><br><span class="line">  <span class="type">int32_t</span> mem;</span><br><span class="line"></span><br><span class="line">  hTask = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!IS_IRQ() &amp;&amp; (func != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="built_in">stack</span> = configMINIMAL_STACK_SIZE;</span><br><span class="line">    prio  = (UBaseType_t)osPriorityNormal;</span><br><span class="line"></span><br><span class="line">    empty = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    name  = &amp;empty;</span><br><span class="line">    mem   = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (attr-&gt;name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        name = attr-&gt;name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (attr-&gt;priority != osPriorityNone) &#123;</span><br><span class="line">        prio = (UBaseType_t)attr-&gt;priority;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((prio &lt; osPriorityIdle) || (prio &gt; osPriorityISR) || ((attr-&gt;attr_bits &amp; osThreadJoinable) == osThreadJoinable)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (attr-&gt;stack_size &gt; <span class="number">0U</span>) &#123;</span><br><span class="line">        <span class="comment">/* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */</span></span><br><span class="line">        <span class="comment">/* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */</span></span><br><span class="line">        <span class="built_in">stack</span> = attr-&gt;stack_size / <span class="keyword">sizeof</span>(StackType_t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((attr-&gt;cb_mem    != <span class="literal">NULL</span>) &amp;&amp; (attr-&gt;cb_size    &gt;= <span class="keyword">sizeof</span>(StaticTask_t)) &amp;&amp;</span><br><span class="line">          (attr-&gt;stack_mem != <span class="literal">NULL</span>) &amp;&amp; (attr-&gt;stack_size &gt;  <span class="number">0U</span>)) &#123;</span><br><span class="line">        mem = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((attr-&gt;cb_mem == <span class="literal">NULL</span>) &amp;&amp; (attr-&gt;cb_size == <span class="number">0U</span>) &amp;&amp; (attr-&gt;stack_mem == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">          mem = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      mem = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">1</span>) &#123;</span><br><span class="line">      hTask = xTaskCreateStatic ((TaskFunction_t)func, name, <span class="built_in">stack</span>, argument, prio, (StackType_t  *)attr-&gt;stack_mem,</span><br><span class="line">                                                                                    (StaticTask_t *)attr-&gt;cb_mem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xTaskCreate ((TaskFunction_t)func, name, (<span class="type">uint16_t</span>)<span class="built_in">stack</span>, argument, prio, &amp;hTask) != pdPASS) &#123;</span><br><span class="line">          hTask = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((osThreadId_t)hTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数开头<code>    stack = configMINIMAL_STACK_SIZE;</code></p><p>参数<code>stack</code>在<code>osThreadNew()</code>函数一开始就被赋值了，若参数<code>attr-&gt;stack_mem</code>缺省，则<code>stack</code>值不会被改变。翻找<code>configMINIMAL_STACK_SIZE</code>定义。<br><code>#define configMINIMAL_STACK_SIZE                 ((uint16_t)128)</code></p><ul><li>也就是说当用户不指定任务栈空间，CMSIS-OS会自动给用户分配128<strong>字</strong>的任务栈。而只有<code>attr-&gt;stack_size </code>的值大于0的时候，才会被除4。</li><li>所以此时的128是以<strong>字</strong>为单位的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (attr-&gt;stack_size &gt; <span class="number">0U</span>) &#123;</span><br><span class="line">  <span class="comment">/* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */</span></span><br><span class="line">  <span class="comment">/* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */</span></span><br><span class="line">  <span class="built_in">stack</span> = attr-&gt;stack_size / <span class="keyword">sizeof</span>(StackType_t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>结论:1.使用静态任务创建需要用户自己指定内存空间大小，参数单位是“字节”，并调用xTaskCreateStatic()。2.使用动态任务创建CMSIS-OS指定了任务栈大小128字，并调用xTaskCreate()。3.用户可以根据需要修改configMINIMAL_STACK_SIZE宏定义的值，来修改attr-&gt;stack_size缺省时任务栈大小的默认值。</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>本站数学方程式渲染模板</title>
      <link href="//article/Mathematical.html"/>
      <url>//article/Mathematical.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇文章仅用作记录满足MathJax渲染条件的数学方程模板…</p></blockquote><span id="more"></span><h2 id="简单方程"><a href="#简单方程" class="headerlink" title="简单方程"></a>简单方程</h2><p>对于简单的方程式<br>$$\begin{equation} \label{eq1}<br>e&#x3D;mc^2<br>\end{equation}$$<br>请使用以下形式给出一个标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;equation&#125; \label&#123;eq1&#125;</span><br><span class="line">e=mc^2</span><br><span class="line">\end&#123;equation&#125;$$</span><br></pre></td></tr></table></figure><p>然后，您可以使用以下内容轻松地在文本中引用此等式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The famous matter-energy equation $\eqref&#123;eq1&#125;$ proposed by Einstein...</span><br></pre></td></tr></table></figure><p>The famous matter-energy equation $\eqref{eq1}$ proposed by Einstein…</p><h2 id="从编号中排除方程式"><a href="#从编号中排除方程式" class="headerlink" title="从编号中排除方程式"></a>从编号中排除方程式</h2><p>在环境中，如果您不想对一个或某些方程进行编号，只需在这些方程后面使用即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;align&#125;</span><br><span class="line">-4 + 5x &amp;= 2 + y \nonumber \\</span><br><span class="line">w + 2 &amp;= -1 + w \\</span><br><span class="line">ab &amp;= cb</span><br><span class="line">\end&#123;align&#125;$$</span><br></pre></td></tr></table></figure><h2 id="使用指定标签标记方程"><a href="#使用指定标签标记方程" class="headerlink" title="使用指定标签标记方程"></a>使用指定标签标记方程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$x+1\over\sqrt&#123;1-x^2&#125; \tag&#123;i&#125;\label&#123;eq_tag&#125;$$</span><br></pre></td></tr></table></figure><p>$$x+1\over\sqrt{1-x^2} \tag{i}\label{eq_tag}$$<br>Equation $\eqref{eq_tag}$ use <code>\tag&#123;&#125;</code> instead of automatic numbering.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于version `GLIBC_2.34&#39; not found解决办法</title>
      <link href="//article/solution_for_version_GLIBC_2_34_not_found.html"/>
      <url>//article/solution_for_version_GLIBC_2_34_not_found.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用arm-linux-gnueabihf-gcc交叉编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc main.c -o main</span><br></pre></td></tr></table></figure><p> 部署到开发板后运行报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debian@npi:~$ ./main </span><br><span class="line">./main: /lib/arm-linux-gnueabihf/libc.so.6: version `GLIBC_2.34<span class="string">&#x27; not found (required by ./main)</span></span><br></pre></td></tr></table></figure><h2 id="查询资料"><a href="#查询资料" class="headerlink" title="查询资料"></a>查询资料</h2><p>使用bing和百度搜索 version &#96;GLIBC_2.34’ not found 得到的解决办法归纳为一下几点</p><ul><li>升级部署环境系统版本，降低打包编译环境的系统版本</li><li><del>在部署环境中下载符合版本的gblc库（一般高于原来的环境）</del> </li><li>使用工具gblc-all-in-one文档描述是</li></ul><blockquote><p>这是一个在ubuntu环境下随意更改文件glibc版本的便捷工具</p></blockquote><ul><li><p>使用静态链接库</p><p>  方法一：可以完美解决，但是太傻了，作为开发人员总不能每次开发一个系统就换自己系统的版本吧。<br>  方法二：看运气，说不定升级了以后开发板的系统命令就用不了了，所以不建议随意升级这个库，具体原因可以<br>  自行百度。<br>  方法三：没看懂原理（刚入门）所以也没去尝试。<br>  方法四：使用静态链接库，缺点是不确定以后会不会出什么问题，而且编译后的文件体积巨大。</p></li></ul><h2 id="整理思路"><a href="#整理思路" class="headerlink" title="整理思路"></a>整理思路</h2><p>我查询了交叉编译的指令具体和GCC差不了多少其中有一<code> -l</code>和<code>-L</code> 命令。<strong>用于指定链接库的链接目录</strong>。具体用法参见<a href="http://c.biancheng.net/view/2382.html">GCC -l选项：手动添加链接库</a>，所以我想能不能在编译的的时候指定需要链接的库或目录，这样就不会需要改变双方的环境了。</p><hr><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><p>查找网络发现在编译c语言时候需要用到的库为<code>libc</code>。<br>我不使用编译器自带的而是从开发板上下载了该文件作为编译文件的链接库。<br>然后在编译的时候指定该文件作为链接目标。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yhw@yhw-virtual-machine:~/gxl$ scp laojia:/lib/libc.so.6 ./   <span class="comment"># 从开发板（服务器）系统的/lib目录下找到libc.so.6下载到当前目录</span></span><br><span class="line">yhw@yhw-virtual-machine:~/gxl$ arm-linux-gnueabihf-gcc main.c -o main ./libc.so.6 <span class="comment">#指定刚刚下载的libc.so.6文件作为编译时候链接文件</span></span><br></pre></td></tr></table></figure><p>然后将程序部署到开发板环境运行成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">debian@npi:~$ ./main <span class="comment">#运行</span></span><br><span class="line">Hello World!</span><br><span class="line">debian@npi:</span><br></pre></td></tr></table></figure><p>而后尝试用指令-L指定一个目录让编译器从其中查找链接库，这样不用一个一个的输入文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhw@yhw-virtual-machine:~/gxl$ arm-linux-gnueabihf-gcc main.c -o main -L ./lib_dir/ <span class="comment">#自行创建文件夹并将文件移入后再执行此步骤</span></span><br></pre></td></tr></table></figure><p>编译通过，完美解决。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>使用编译器<code>-l</code>和<code>-L</code>选项手动添加从目标系统下载的链接库从而解决gblc版本不匹配的问题。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
