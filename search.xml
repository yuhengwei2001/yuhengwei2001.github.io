<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>本站主题配置</title>
      <link href="//article/blogsetting.html"/>
      <url>//article/blogsetting.html</url>
      
        <content type="html"><![CDATA[<!-- <div class="note modern"><p>none</p></div><div class="note default modern"><p>default</p></div><div class="note primary modern"><p>primary</p></div><div class="note success modern"><p>success</p></div><div class="note info modern"><p>info</p></div><div class="note warning modern"><p>warning</p></div><div class="note danger modern"><p>danger</p></div> --><div class="note info modern"><p>文章对主题<code>_config.yml</code>与<code>_config.butterfly.yml</code>文件的修改不做记录。若有看不懂的地方，请先认真阅读<a href="https://butterfly.js.org/posts/21cfbf15/">安装文档</a>后欢迎评论或邮件提问探讨。</p></div><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本站使用Hexo框架搭建，主题为Butterfly。</p><p>本篇为本博客更改主题文件配置信息，为有需要做相同修改的朋友，或者将来主题更新适配留作说明。</p><h2 id="修改首页标题显示"><a href="#修改首页标题显示" class="headerlink" title="修改首页标题显示"></a>修改首页标题显示</h2><p>博客首页标题默认显示为<code>_config.yml</code>文件中配置的<code>title</code>项目。<br>在<code>/themes/butterfly/layout/includes/header/index.pug</code>文件中找到<code>site_title</code>变量赋值处，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- var site_title = page.title || page.tag || page.category || config.title</span><br></pre></td></tr></table></figure><p>这句话的意思是，该页面显示的标题有优先级，先后取自，文章标题，标签，分类，<code>_config.yml</code>文件<code>title</code>项。</p><p>想自定义首页标题，在<code>config.title</code>项前添加<code>theme.blog_name</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- var site_title = page.title || page.tag || page.category || theme.blog_name || config.title</span><br></pre></td></tr></table></figure><p>而后去<code>_config.butterfly.yml</code>随意找一处(建议在开头)添加配置项<code>blog_name</code>，本站配置如下，不需要缩进。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">blog_name:</span> <span class="string">雾里看花，刹那芳华</span></span><br></pre></td></tr></table></figure><h2 id="修改顶部导航栏搜索图标排序"><a href="#修改顶部导航栏搜索图标排序" class="headerlink" title="修改顶部导航栏搜索图标排序"></a>修改顶部导航栏搜索图标排序</h2><p>找到文件<code>/themes/butterfly/layout/includes/header/nav.pug</code>修改将菜单配置移到搜索配置之前，注释掉搜索文字就可以只得到一个搜索按钮，希望保留的可以不注释<code>- span=&#39; &#39;+_p(&#39;search.title&#39;)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">nav#nav</span><br><span class="line">  span#blog-info</span><br><span class="line">    a(href=url_for(&#x27;/&#x27;) title=config.title)</span><br><span class="line">      if theme.nav.logo</span><br><span class="line">        img.site-icon(src=url_for(theme.nav.logo))</span><br><span class="line">      if theme.nav.display_title</span><br><span class="line">        span.site-name=config.title</span><br><span class="line">    </span><br><span class="line">  #menus</span><br><span class="line">    !=partial(&#x27;includes/header/menu_item&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">    if (theme.algolia_search.enable || theme.local_search.enable || theme.docsearch.enable)</span><br><span class="line">      #search-button</span><br><span class="line">        a.site-page.social-icon.search(href=&quot;javascript:void(0);&quot;)</span><br><span class="line">          i.fas.fa-search.fa-fw</span><br><span class="line">          //- span=&#x27; &#x27;+_p(&#x27;search.title&#x27;)</span><br><span class="line">    //- !=partial(&#x27;includes/header/menu_item&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line"></span><br><span class="line">    #toggle-menu</span><br><span class="line">      a.site-page(href=&quot;javascript:void(0);&quot;)</span><br><span class="line">        i.fas.fa-bars.fa-fw</span><br></pre></td></tr></table></figure><h2 id="修改侧栏作者卡"><a href="#修改侧栏作者卡" class="headerlink" title="修改侧栏作者卡"></a>修改侧栏作者卡</h2><p>找到文件<code>/themes/butterfly/layout/includes/widget/card_author.pug</code><br>我将以下代码注释后获得了简洁的卡片内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">if theme.aside.card_author.enable</span><br><span class="line">  .card-widget.card-info</span><br><span class="line">    .is-center</span><br><span class="line">      .avatar-img</span><br><span class="line">        img(src=url_for(theme.avatar.img) onerror=`this.onerror=null;this.src=&#x27;` + url_for(theme.error_img.flink) + `&#x27;` alt=&quot;avatar&quot;)</span><br><span class="line">      .author-info__name= config.author</span><br><span class="line">      .author-info__description!= theme.aside.card_author.description || config.description</span><br><span class="line"></span><br><span class="line">    //- .card-info-data.site-data.is-center</span><br><span class="line">    //-   a(href=url_for(config.archive_dir) + &#x27;/&#x27;)</span><br><span class="line">    //-     .headline= _p(&#x27;aside.articles&#x27;)</span><br><span class="line">    //-     .length-num= site.posts.length</span><br><span class="line">    //-   a(href=url_for(config.tag_dir) + &#x27;/&#x27;)</span><br><span class="line">    //-     .headline= _p(&#x27;aside.tags&#x27;)</span><br><span class="line">    //-     .length-num= site.tags.length</span><br><span class="line">    //-   a(href=url_for(config.category_dir) + &#x27;/&#x27;)</span><br><span class="line">    //-     .headline= _p(&#x27;aside.categories&#x27;) </span><br><span class="line">    //-     .length-num= site.categories.length</span><br><span class="line"></span><br><span class="line">    if theme.aside.card_author.button.enable</span><br><span class="line">      a#card-info-btn(href=theme.aside.card_author.button.link)</span><br><span class="line">        i(class=theme.aside.card_author.button.icon)</span><br><span class="line">        span=theme.aside.card_author.button.text</span><br><span class="line">  </span><br><span class="line">    if(theme.social)</span><br><span class="line">        .card-info-social-icons.is-center</span><br><span class="line">          !=partial(&#x27;includes/header/social&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="固定导航栏"><a href="#固定导航栏" class="headerlink" title="固定导航栏"></a>固定导航栏</h2><p>找到文件<code>/themes/butterfly/source/js/main.js</code>，修改网页滑动逻辑判定,全篇代码太长，仅给出有做修改段代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// let flag = &#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> scrollTask = btf.<span class="title function_">throttle</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> currentTop = <span class="variable language_">window</span>.<span class="property">scrollY</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span></span><br><span class="line">    <span class="keyword">const</span> isDown = <span class="title function_">scrollDirection</span>(currentTop)</span><br><span class="line">    <span class="keyword">if</span> (currentTop === <span class="number">0</span>) &#123;</span><br><span class="line">      $header.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;nav-fixed&#x27;</span>, <span class="string">&#x27;nav-visible&#x27;</span>)</span><br><span class="line">      isChatBtn &amp;&amp; <span class="variable language_">window</span>.<span class="property">chatBtn</span>.<span class="title function_">show</span>()</span><br><span class="line">      $rightside.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;rightside-show&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      $rightside.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;rightside-show&#x27;</span>)</span><br><span class="line">      isChatBtn &amp;&amp; <span class="variable language_">window</span>.<span class="property">chatBtn</span>.<span class="title function_">hide</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if (currentTop &gt; 56) &#123;</span></span><br><span class="line">    <span class="comment">//   if (flag === &#x27;&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//     $header.classList.add(&#x27;nav-fixed&#x27;)</span></span><br><span class="line">    <span class="comment">//     $rightside.classList.add(&#x27;rightside-show&#x27;)</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//   if (isDown) &#123;</span></span><br><span class="line">    <span class="comment">//     if (flag !== &#x27;down&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//       $header.classList.remove(&#x27;nav-visible&#x27;)</span></span><br><span class="line">    <span class="comment">//       isChatBtn &amp;&amp; window.chatBtn.hide()</span></span><br><span class="line">    <span class="comment">//       flag = &#x27;down&#x27;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//   &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//     if (flag !== &#x27;up&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//       $header.classList.add(&#x27;nav-visible&#x27;)</span></span><br><span class="line">    <span class="comment">//       isChatBtn &amp;&amp; window.chatBtn.show()</span></span><br><span class="line">    <span class="comment">//       flag = &#x27;up&#x27;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//   flag = &#x27;&#x27;</span></span><br><span class="line">    <span class="comment">//   if (currentTop === 0) &#123;</span></span><br><span class="line">    <span class="comment">//     $header.classList.remove(&#x27;nav-fixed&#x27;, &#x27;nav-visible&#x27;)</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">//   $rightside.classList.remove(&#x27;rightside-show&#x27;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    isShowPercent &amp;&amp; <span class="title function_">rightsideScrollPercent</span>(currentTop)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollHeight</span> &lt;= innerHeight) &#123;</span><br><span class="line">      $rightside.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;rightside-show&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">  btf.<span class="title function_">addEventListenerPjax</span>(<span class="variable language_">window</span>, <span class="string">&#x27;scroll&#x27;</span>, scrollTask, &#123; <span class="attr">passive</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加个人GitHub贡献度日历"><a href="#添加个人GitHub贡献度日历" class="headerlink" title="添加个人GitHub贡献度日历"></a>添加个人GitHub贡献度日历</h2><p>参考博客<a href="https://blog.meta-code.top/2022/03/15/2022-41/">百里飞洋 Barry-Flynn</a>，感谢大佬解答，以及提供了插件以及后端API维护,请前往其仓库了解详情。</p><ul><li><p><a href="https://github.com/Barry-Flynn/hexo-github-calendar">前端Hexo插件</a></p></li><li><p><a href="https://github.com/Barry-Flynn/python_github_calendar_api">后端API部署</a></p><div class="note warning modern"><p>Vercel域名被墙，需要用自己的域名做解析。</p></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>傅里叶变换原理(简易)</title>
      <link href="//article/FFT.html"/>
      <url>//article/FFT.html</url>
      
        <content type="html"><![CDATA[<!-- >由实际应用倒推算法原理，暴力拆解傅里叶变换(Fourier Transform)的信号处理上的原理。尽量摒弃繁杂的数学定义了解，直观的描述快速傅里叶到底对信号做了什么处理？阅读本文章的可以是对傅里叶变换公式推导毫无了解的朋友，因为这篇文章不从推导入手，而直接傅里叶变换公式入手，告诉你如何通过一系列的操作得到信号的频域图。至于如何推导傅里叶变换公式等以后有空再写一篇吧！感兴趣的朋友可以先去网上搜索一番。more --><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><h3 id="连续与离散"><a href="#连续与离散" class="headerlink" title="连续与离散"></a>连续与离散</h3><p>一般人们口中所说的傅里叶变换都是指连续傅里叶变换，针对的是连续时域信号。维基百科上是这么描述<a href="https://zh.wikipedia.org/wiki/%E8%BF%9E%E7%BB%AD%E4%BF%A1%E5%8F%B7"><strong>连续信号</strong></a>的：</p><blockquote><p>连续信号或称连续时间信号是指定义在实数域的信号，自变量（一般是时间）的取值连续。若信号的幅值和自变量均连续，则称为模拟信号。根据实数的性质，时间参数的连续性意味着信号的值在时间的任意点均有定义。</p></blockquote><p>简单来说，对于一个sin函数的连续信号，其波形长这样:</p><center><img src="https://s2.loli.net/2024/03/08/GWz9RA8xyJgZvcp.png"/></center><p>对于计算设备的信号处理，因为采样设备的采样率是有限的。因此得到的采样信号都是离散的，所以就有了针对离散信号的离散傅里叶变换。维基百科是这么描述<a href="https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E4%BF%A1%E5%8F%B7"><strong>离散信号</strong></a>:</p><blockquote><p>离散信号是在连续信号上采样得到的信号。与连续信号的自变量是连续的不同，离散信号是一个串行，即其自变量是“离散”的。这个串行的每一个值都可以被看作是连续信号的一个采样。由于离散信号只是采样的串行，并不能从中获得采样率，因此采样率必须另外存储。以时间为自变量的离散信号为离散时间信号。<br>离散信号并不等同于数字信号。数字信号不仅是离散的，而且是经过量化的。即，不仅其自变量是离散的，其值也是离散的。因此离散信号的精度可以是无限的，而数字信号的精度是有限的。而有着无限精度，亦即在值上连续的离散信号又叫抽样信号。所以离散信号包括了数字信号和抽样信号。</p></blockquote><center><img src="https://s2.loli.net/2024/03/08/Ui76ryaEOM3FGHl.png"/></center><h3 id="傅里叶变换公式实际意义"><a href="#傅里叶变换公式实际意义" class="headerlink" title="傅里叶变换公式实际意义"></a>傅里叶变换公式实际意义</h3><p>直接看傅里叶变换公式：</p><p>$$<br>\begin{align}<br>{F}(\omega) &#x3D; \int_{-\infty}^{\infty} f(t)e^{-j\omega t}dt<br>\end{align}<br>$$</p><p>其中</p><ul><li>$f(t)$频谱未知信号，我们就是对这个信号做傅里叶变换。</li><li>$F(\omega)$为傅里叶变换后的频谱函数。其自变量为$\omega$频率。</li><li>$e^{-j\omega t}$为复信号</li></ul><p>要理解这个公式，关键就在于$e^{-j\omega t}$怎么理解。本科学过复变函数的同学应该都知道，指数复变函数是可以转化为三角函数形式的。其变换公式如下:</p><p>$$<br>\begin{align}<br>e^{-j\omega t} &#x3D; cos(\omega t)-jsin(\omega t)<br>\end{align}<br>$$</p><p>那么将（2）式代入（1）式可以很快得出:<a id="公式3"></a></p><p>$$<br>\begin{align}<br>{F}(\omega) &#x3D; \int_{-\infty}^{\infty} f(t)(cos(\omega t)-jsin(\omega t))dt<br>\end{align}<br>$$<br>由上式可得，<strong>要想得到信号频域与相位信息只需要将信号与复数信号做乘法后积分</strong>。</p><h3 id="信号的筛选"><a href="#信号的筛选" class="headerlink" title="信号的筛选"></a>信号的筛选</h3><p>简单概括公式所表达的实际意义后，我们再来看为什么要这么做。废话少说直接按照傅里叶变换公式所描述的做法，将信号与各已频率信号乘法后积分，写一段简单的matlab程序。最终结果如下图:</p><center><img src="https://s2.loli.net/2024/03/11/fDb6sMc3rzO1Pen.gif"/></center><ul><li>框图1内蓝色信号线为MATLAB生成需要做傅里叶变换的随机频率的信号(未知信号)，红色信号线为频率不断增大的正弦信号，红色信号是人为生成的(基信号)，因此其频率是可知的。</li><li>框图2为两正弦波相乘结果。</li><li>框图3是对正弦波乘积结果的积分。</li></ul><p>从图上可以很清楚直观的看出，当未知信号与基信号频率相同时，他们乘积的积分达到了最大。而这个积分最终的图像是不是就很像信号经过傅里叶变换后的频域图像呢！利用了乘法负负得正的特性，当基信号与未知信号频率完全相同的时候，其时域上乘积全为正数。因此，此时的积分达到最大值。通过此类操作即可得到未知信号的频率。</p><p><strong>说人话，就是用各种频率的基信号与未知信号做对比，看看哪个频率的基信号与未知信号最像！！！，而这个对比的方法，用数学来描述就是先相乘后积分，这样描述的话，是不是听起来就没那么复杂了。</strong></p><p>用公式描述就是：<a id="公式4"></a><br>$$<br>\begin{align}<br>{F}(\omega) &#x3D; \int_{-\infty}^{\infty}f(t)sin(\omega t)dt<br>\end{align}<br>$$<br>可以看到,已经离上文所示的傅里叶变换公式(3)有点相像了！</p><blockquote><p><strong>Q:</strong> 单个频率成分信号可以，那多个呢？</p></blockquote><p>那自然也是这么做的，废话少说，直接上图：</p><center><img src="https://s2.loli.net/2024/03/11/PxkYMiIqDoy89uU.gif"/></center><p>由此可以看出，<strong>用这种方式可以筛选出未知信号中各种频率成分</strong>，至于为什么可以？前面说过了，本文只讨论傅里叶变换做法，暂不对其数学原理做深入探究，想要深入了解的朋友可以自行搜索，或关注我的博客，或许不久后将更新此方面的内容。</p><h3 id="初始相位的问题"><a href="#初始相位的问题" class="headerlink" title="初始相位的问题"></a>初始相位的问题</h3><p>上文所讨论的对未知信号频率的筛选，全部都是建立在未知信号相位为0的情况下。但是实际使用过程中，信号的相位与频率都是未知的，若只使用上文（4）所描述的方式肯定是不行的，如下图：</p><center><img src="https://s2.loli.net/2024/03/11/LiJkl3aSFY6C1qt.png"/></center><p>可以看到若未知信号的初始相位为90°，若还使用<a href="#%E5%85%AC%E5%BC%8F4"><strong>公式4</strong></a>，得出的结果与实际就有误了。</p><p>此时再回头看看傅里叶变换的公式，不难发现，<a href="#%E5%85%AC%E5%BC%8F3"><strong>傅里叶变换</strong></a>使用的是复数信号。$e^{-j\omega t} &#x3D; cos(\omega t)-jsin(\omega t)$。也就是说傅里叶变换对未知信号使用复数信号相乘后求积分。而不是只对单个正弦信号做比较。</p><p>不难看出，傅里叶变换的结果是复数信号，其结果实部的值就是表示未知信号与cos信号的相关度，虚部值表示未知信号与sin信号的相关度。由此可以看出，傅里叶变换的结果还包含了未知信号的相位信息。</p><p>为了分析其频率信息，我们可以对结果做取模开方处理，也就是:<br>$$<br>    \sqrt(R^2+I^2)<br>$$<br>结果如下图:</p><center><img src="https://s2.loli.net/2024/03/11/KoVuc13fFasLRWT.gif"/></center><p>可以看到位置信号的频率成分已经被解析出来了,这里注意一点,上文是做了开平方处理，也就是说解除了在正频域，在负频域也有频率分量。</p><h2 id="离散傅里叶变换-DFT"><a href="#离散傅里叶变换-DFT" class="headerlink" title="离散傅里叶变换(DFT)"></a>离散傅里叶变换(DFT)</h2><p>离散傅里叶变换实际上是按照傅里叶变换的定义对离散的数字信号进行计算，积分变成了连加，频率间隔根据采样点数的倒数确定,公式如下:</p><p>$$<br>X[k]&#x3D;\sum_{n&#x3D;0}^{N-1}{x[n]e^{-j(2\pi&#x2F;N)kn}}<br>$$</p><h3 id="采样带来的频谱镜像问题"><a href="#采样带来的频谱镜像问题" class="headerlink" title="采样带来的频谱镜像问题"></a>采样带来的频谱镜像问题</h3><p>为了对连续信号做傅里叶变换，我们需要对信号进行采样，采样后得到的离散信号才可以用于计算机计算，做DFT。这里有一个采样导致的镜像问题。</p><p>首先，根据奈奎斯特采样定理:</p><blockquote><p>要从抽样信号中无失真地恢复原信号，抽样频率应大于2倍信号最高频率。 抽样频率小于2倍频谱最高频率时，信号的频谱有混叠。 抽样频率大于2倍频谱最高频率时，信号的频谱无混叠。</p></blockquote><p>说白了，要保留信号的基本信息，我们需要对信号进行信号至少两倍频率的采样。而数字设备采样可以看作连续信号乘以采样频率的<a href="https://baike.baidu.com/item/%E7%8B%84%E6%8B%89%E5%85%8B%E6%A2%B3%E7%8A%B6%E5%87%BD%E6%95%B0/20393728">狄拉克梳状函数</a>。</p><p>这里需要注意一点，我刚刚的描述是<strong>连续信号乘以采样频率的狄拉克梳状函数</strong>，也就是说，采样实际上可以理解为被采样信号与采样信号相乘。根据卷积定理，<strong>信号时域相乘等于频域卷积</strong>。等于说被采样信号与采样信号做了混频。</p><p>假设被采样信号频率为100Hz，采样信号频率为1000Hz，那么对采样后的信号做DFT，在正频域上会得到100Hz，900Hz以及1100Hz的频谱。由于采样频率是1000Hz，因此在区间内会只有100Hz以及900Hz的频谱,这900Hz的频谱就是采样后离散信号的镜像。</p><ul><li><p>奈奎斯特低通采样实际局限性</p><p> 现如今通信设备采用的发送频率上到千兆，这对接收端ADC带来了很大的挑战。假设一个处于2GHz频段的信号，若要根据奈奎斯特（低通）采样率采样，则需要至少能做到4GHz的采样的ADC器件。先不说没有这么高频的采样芯片，就算有，成本也是巨大的。<br> 再者，虽然信号处于2GHz的频段，但确实带通信号，只有处于2GHz周围的频段被用作数据传输，带传输带宽之外的频域没有信息传递。因此若对2GHz信号进行低通采样会造成极大的资源浪费。<br> 但与单音信号不同的是，通信设备所发送的信号频率与带宽都是提前可知的，这对我们信号处理提供了有利条件。</p></li></ul><h3 id="带通采样"><a href="#带通采样" class="headerlink" title="带通采样"></a>带通采样</h3><p>带通采样的原理可以理解为，利用采样函数对被采样函数做频谱搬移。注意，频谱搬移需要避免频率混叠，具体推导以及原理这篇<a href="https://blog.csdn.net/weixin_45317919/article/details/131906305">博客</a>做了详细叙述。</p><p>有点技术手段的可以参考<a href="http://www.ws.binghamton.edu/fowler/fowler%20personal%20page/EE521_files/II-2%20BP%20Sampling_2007.pdf">这篇PDF</a></p><h2 id="FFT诞生历史"><a href="#FFT诞生历史" class="headerlink" title="FFT诞生历史"></a>FFT诞生历史</h2><p>1963年8月美、英、苏三国在莫斯科谈判，达成协议签定了该条约，全称为《关于禁止在大气层、外层空间和水下进行核武器爆炸实验的条约》又称〈部分核禁止条约〉或三家条约。可以注意到，条约中不包括地下核武器爆炸实验，这是因为地下核实验难以被检测到，大地隔绝了大部分的辐射，声音。使得其难以想地上或水下核试验一样容易被探测到。要想探测地下核试验，主要靠分析地动信息。但如何将日常地址活动造成的地动与核试验造成的地动区分开来成为了当时科学家所难以解决的问题。在快速傅里叶算法还未发现之前，按照离散傅里叶定义使用计算机对地动信号做频谱分析，算力远远不足，分析出的数据严重过时。因此在这个背景下，快速傅里叶变换的算法出现了。</p><h2 id="快速傅里叶变换-FFT"><a href="#快速傅里叶变换-FFT" class="headerlink" title="快速傅里叶变换(FFT)"></a>快速傅里叶变换(FFT)</h2><p>快速傅里叶算法本质上是对离散傅里叶变化的改进，本质上是利用矩阵乘法时不同基信号在奇数或偶数点的与被采样信号的乘积相同来减少计算，严格的数学推断可以参考这篇<a href="https://zhuanlan.zhihu.com/p/407885496">快速理解FFT算法（完整无废话）</a></p><h2 id="MATLAB-仿真代码"><a href="#MATLAB-仿真代码" class="headerlink" title="MATLAB 仿真代码"></a>MATLAB 仿真代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 设置时间范围</span></span><br><span class="line">t = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">freq1 = <span class="number">5</span>;</span><br><span class="line">freq2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建GIF文件</span></span><br><span class="line">filename = <span class="string">&#x27;sin_wave_animation.gif&#x27;</span>;</span><br><span class="line">fps = <span class="number">120</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化乘积结果的和</span></span><br><span class="line">sum_of_product = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(t));</span><br><span class="line">sum_of_product_sin = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(t));</span><br><span class="line">sum_of_product_cos = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(t));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(t)</span><br><span class="line">    <span class="comment">% 生成两个不同频率的正弦波</span></span><br><span class="line">    y1 = <span class="built_in">cos</span>(freq1 * t);</span><br><span class="line">    y2 = <span class="built_in">sin</span>((freq2+<span class="built_in">i</span>/<span class="number">10</span>) * t);</span><br><span class="line">    y3 = <span class="built_in">cos</span>((freq2+<span class="built_in">i</span>/<span class="number">10</span>) * t);</span><br><span class="line">    <span class="comment">% 计算两个正弦波的乘积</span></span><br><span class="line"></span><br><span class="line">    y_product_sin = y1 .* y2;</span><br><span class="line">    y_product_cos = y1 .* y3;</span><br><span class="line">    <span class="comment">% 计算乘积结果的和</span></span><br><span class="line">    sum_of_product_sin(<span class="built_in">i</span>+<span class="number">1</span>) = sum(y_product_sin);</span><br><span class="line">    sum_of_product_cos(<span class="built_in">i</span>+<span class="number">1</span>) = sum(y_product_cos);</span><br><span class="line">    </span><br><span class="line">    sum_of_product = <span class="built_in">sqrt</span>(power(sum_of_product_sin, <span class="number">2</span>) + power(sum_of_product_cos, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    arr = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">    subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">plot</span>(arr(<span class="number">1</span>:<span class="built_in">i</span>), sum_of_product_sin(<span class="number">1</span>:<span class="built_in">i</span>), <span class="string">&#x27;g&#x27;</span>); <span class="comment">% 只绘制当前时间点之前的数据</span></span><br><span class="line">    xlabel(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    ylabel(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">    xlim([<span class="number">0</span>, <span class="number">10</span>]);</span><br><span class="line">    ylim([<span class="number">-500</span>, <span class="number">500</span>]);</span><br><span class="line">    title(<span class="string">&#x27;Re&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    arr = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">    subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">plot</span>(arr(<span class="number">1</span>:<span class="built_in">i</span>), sum_of_product_cos(<span class="number">1</span>:<span class="built_in">i</span>), <span class="string">&#x27;g&#x27;</span>); <span class="comment">% 只绘制当前时间点之前的数据</span></span><br><span class="line">    xlabel(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    ylabel(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">    xlim([<span class="number">0</span>, <span class="number">10</span>]);</span><br><span class="line">    ylim([<span class="number">-500</span>, <span class="number">500</span>]);</span><br><span class="line">    title(<span class="string">&#x27;Im&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    arr = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">    subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">plot</span>(arr(<span class="number">1</span>:<span class="built_in">i</span>), sum_of_product(<span class="number">1</span>:<span class="built_in">i</span>), <span class="string">&#x27;g&#x27;</span>); <span class="comment">% 只绘制当前时间点之前的数据</span></span><br><span class="line">    xlabel(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    ylabel(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">    xlim([<span class="number">0</span>, <span class="number">10</span>]);</span><br><span class="line">    ylim([<span class="number">-500</span>, <span class="number">500</span>]);</span><br><span class="line">    title(<span class="string">&#x27;sqrt(power(Re, 2) + power(Im, 2));&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 保存当前图像为GIF</span></span><br><span class="line">    frame = getframe(gcf);</span><br><span class="line">    im = frame2im(frame);</span><br><span class="line">    [imind, cm] = rgb2ind(im, <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">i</span> == <span class="number">1</span></span><br><span class="line">        imwrite(imind, cm, filename, <span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;Loopcount&#x27;</span>, <span class="built_in">inf</span>, <span class="string">&#x27;DelayTime&#x27;</span>, <span class="number">1</span>/fps);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        imwrite(imind, cm, filename, <span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;WriteMode&#x27;</span>, <span class="string">&#x27;append&#x27;</span>, <span class="string">&#x27;DelayTime&#x27;</span>, <span class="number">1</span>/fps);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">i</span> == <span class="number">100</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GT Wizard 多通道问题</title>
      <link href="//article/GT_Wizard_MultiChannel_issue.html"/>
      <url>//article/GT_Wizard_MultiChannel_issue.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在使用Xilinx提供的GT Wizard IP核时例化了多个两个收发通道，前期测试时只接了通道0，测试正常。但后期接入通道1时出现问题。当我断开通道0，只连接通道1时，数据接收错乱了。多方查询后发现是使用Vivado生成的仿真例程有问题，修改例程文件中的时钟连接逻辑即可解决例化多通道时只使用单通道有可能出现数据时钟错乱的问题。</p></blockquote><span id="more"></span><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Vivado 2021.2.1</li><li>VScode Portable</li></ul><h2 id="分析解决"><a href="#分析解决" class="headerlink" title="分析解决"></a>分析解决</h2><h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><p>右键IP核生成IP仿真例程后，可以在工程列表中找到类似<code>gtwizard_0_GT_USRCLK_SOURCE。v</code>的文件，这是用于配置GTX时钟资源的文件，其中在末尾的发送与接收时钟输出的语句可以看到问题所在，<strong>例程在仿真时输出的时钟全部采用通道0的时钟，因此在综合后上板子调试后，若通道0空载，则输出的恢复时钟混乱造成数据处理时序混乱</strong>。代码如下:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Instantiate a MMCM module to divide the reference clock. Uses internal feedback</span></span><br><span class="line">    <span class="comment">// for improved jitter performance， and to avoid consuming an additional BUFG</span></span><br><span class="line"></span><br><span class="line">    BUFG txoutclk_bufg0_i</span><br><span class="line">    (</span><br><span class="line">        <span class="variable">.I</span>                              (gt0_txoutclk_i)，</span><br><span class="line">        <span class="variable">.O</span>                              (gt0_txusrclk_i)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    BUFG rxoutclk_bufg1_i</span><br><span class="line">    (</span><br><span class="line">        <span class="variable">.I</span>                              (gt0_rxoutclk_i)，</span><br><span class="line">        <span class="variable">.O</span>                              (gt0_rxusrclk_i)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> GT0_TXUSRCLK_OUT = gt0_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT0_TXUSRCLK2_OUT = gt0_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT0_RXUSRCLK_OUT = gt0_rxusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT0_RXUSRCLK2_OUT = gt0_rxusrclk_i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">assign</span> GT1_TXUSRCLK_OUT = gt0_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT1_TXUSRCLK2_OUT = gt0_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT1_RXUSRCLK_OUT = gt0_rxusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT1_RXUSRCLK2_OUT = gt0_rxusrclk_i;</span><br></pre></td></tr></table></figure><h3 id="问题定位-1"><a href="#问题定位-1" class="headerlink" title="问题定位"></a>问题定位</h3><p>因此，需要将通道1的时钟源修改回其原本的内部恢复&#x2F;发送时钟。需要增加一些两个BUFG的资源，代码如下:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Instantiate a MMCM module to divide the reference clock. Uses internal feedback</span></span><br><span class="line">    <span class="comment">// for improved jitter performance， and to avoid consuming an additional BUFG</span></span><br><span class="line"></span><br><span class="line">    BUFG txoutclk_bufg0_i0</span><br><span class="line">    (</span><br><span class="line">        <span class="variable">.I</span>                              (gt0_txoutclk_i)，</span><br><span class="line">        <span class="variable">.O</span>                              (gt0_txusrclk_i)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    BUFG rxoutclk_bufg1_i0</span><br><span class="line">    (</span><br><span class="line">        <span class="variable">.I</span>                              (gt0_rxoutclk_i)，</span><br><span class="line">        <span class="variable">.O</span>                              (gt0_rxusrclk_i)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    BUFG txoutclk_bufg0_i1</span><br><span class="line">    (</span><br><span class="line">        <span class="variable">.I</span>                              (gt1_txoutclk_i)，</span><br><span class="line">        <span class="variable">.O</span>                              (gt1_txusrclk_i)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    BUFG rxoutclk_bufg1_i1</span><br><span class="line">    (</span><br><span class="line">        <span class="variable">.I</span>                              (gt1_rxoutclk_i)，</span><br><span class="line">        <span class="variable">.O</span>                              (gt1_rxusrclk_i)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> GT0_TXUSRCLK_OUT = gt0_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT0_TXUSRCLK2_OUT = gt0_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT0_RXUSRCLK_OUT = gt0_rxusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT0_RXUSRCLK2_OUT = gt0_rxusrclk_i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">assign</span> GT1_TXUSRCLK_OUT = gt1_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT1_TXUSRCLK2_OUT = gt1_txusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT1_RXUSRCLK_OUT = gt1_rxusrclk_i;</span><br><span class="line"><span class="keyword">assign</span> GT1_RXUSRCLK2_OUT = gt1_rxusrclk_i;</span><br></pre></td></tr></table></figure><p>修改之后，通道0与通道1的时钟域相互独立，接收数据后使用FIFO或RAM将数据同步到FPGA内部时钟域下进行进一步处理，发送也同理。</p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数字下变频(DDC)、数字上变频(DUC)</title>
      <link href="//article/DDC_DUC.html"/>
      <url>//article/DDC_DUC.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>概述了数字变频的数学原理与实际使用情况,使用Matlab仿真,先构造频域连续的宽带信号模拟基带数字信号,如果利用傅里叶反变换构造了时域信号用于仿真.文章给出了仿真代码与结果图.</p></blockquote><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在无线通信中，数据由核心网下传至基站，基站经过处理后变成电磁信号对外发送，最后到达用户端。在基站中，核心网下发的未被处理过的数字信号被称为基带信号。基带信号通常是零频宽&#x2F;窄带信号。基带信号的采样率较低，不能满足射频发射的要求，所以基带信号往往经过滤波和内插转换成高采样率，从而调制到中频载波频率上.<br>此时若基站接收到两路不同的基带信号，则无法做模拟上变频到同一频段，因为从频谱上看两个基带信号频谱叠加了，<a href="#%E9%A2%91%E8%B0%B1%E5%8F%A0%E5%8A%A0"><strong>相互干扰</strong></a>。若使用两个频段对外发送则过于浪费频谱资源了。在同一空间内，通信信道是有限的，因此需要在模拟上变频之前先做数字上变频，将两路基带信号调制到一起，成为在频谱上连续的基带信号后，做模拟上变频，调制到中高频后对外发送。这样就只会占用一条中频带，节约了无线资源。</p><blockquote><p>具体可以看这篇博客<a href="https://blog.csdn.net/HiWangWenBing/article/details/112306673">[4G&amp;5G专题-9]：RRU 数字上变频DUC与数字下变频DDC</a>。</p></blockquote><h2 id="数字上变频-DUC-数学原理"><a href="#数字上变频-DUC-数学原理" class="headerlink" title="数字上变频(DUC)数学原理"></a>数字上变频(DUC)数学原理</h2><p>数字上变频本质是是将一个处于零频的宽带信号搬移至高于零频的频段。原理上就是信号的调制，数学原理可以参考：<a href="https://blog.csdn.net/HiWangWenBing/article/details/110162546">通信系统中的调制解调</a>。</p><p>从公式上看频谱搬移可以通过时域中的信号乘以一个<a href="https://blog.csdn.net/weixin_38939826/article/details/102893656">单音信号</a>实现，公式如下:<br>$$<br>y(t) &#x3D; x(t)*cos(\omega_1t)<br>$$</p><p>其中$x(t)$为需要调制的信号，假设也为一个单音信号$sin(\omega_0t)$则:<br>$$<br>\begin{align}<br>y(t) &amp;&#x3D; sin(\omega_0t) * cos(\omega_1t) \nonumber\\<br>     &amp;&#x3D; \frac{sin(\omega_0+\omega_1)+cos(\omega_0-\omega_1)}{2} \nonumber<br>\end{align}<br>$$<br>由上可以得出频谱搬移后会出现镜像分别为$\omega_0+\omega_1$和$\omega_0-\omega_1$这两个频率上。但在基带处理中基带信号一般为<a href="https://rf.eefocus.com/article/id-335996">IQ信号</a>，因此用于调制的信号也该是个复数信号。<br>所以有</p><p>$$<br>y(t) &#x3D; x(t)*e^{j2\pi f_0 t}<br>$$</p><p>其中</p><ul><li>$x(t)$是基带信号</li><li>$e^{j2\pi f_0 t}$是复指数信号，可以看作载波信号。</li><li>$f_0$是搬移的频率，决定了搬移的幅度和方向。</li></ul><p>复指数信号的时域表达式为：</p><p>$$<br>    e^{j2\pi f_0 t} &#x3D; \cos(\omega_1t) + j \sin(\omega_1t)<br>$$</p><p>因此从时域上看:<br>$$<br>    y(t) &#x3D; x(t) * [cos(\omega_1t)+jsin(\omega_1t)]<br>$$</p><p>假设基带信号为<a href="https://blog.csdn.net/weixin_38939826/article/details/102893656">单音信号</a>,其时域上三角函数表达式为:</p><p>$$<br>    x(t)&#x3D;cos(\omega_0t)+jsin(\omega_0t)<br>$$</p><p>则时域的频谱搬移可以由下表示:<br>$$ \begin{align}<br>    y(t) &amp;&#x3D; [cos(\omega_0t)+jsin(\omega_0t)]*[cos(\omega_1t)+jsin(\omega_1t)] \nonumber\\<br>     &amp;&#x3D;[cos(\omega_0t)cos(\omega_1t)-sin(\omega_0t)sin(\omega_1t)]+j[cos(\omega_0t)sin(\omega_1t)+sin(\omega_0t)cos(\omega_1t)] \nonumber\\<br>     &amp;&#x3D;cos[(\omega_0+\omega_1)t]+jsin[(\omega_0+\omega_1)t] \nonumber<br>\end{align}<br>$$<br>由上面的计算可以看出原信号被搬移到了$\omega_0+\omega_1$上，若想得到位于$\omega_0-\omega_1$的信号则对IQ信号做差运算即可因为在FPGA中基带信号的实部和虚部是存在不同的变量中，可以单独拿出来做运算。复数在变换完成后可以只留下一个频率，这对我们基带处理带来了很大的便利。</p><h2 id="Matlab模拟"><a href="#Matlab模拟" class="headerlink" title="Matlab模拟"></a>Matlab模拟</h2><h3 id="建立基带时域信号"><a href="#建立基带时域信号" class="headerlink" title="建立基带时域信号"></a>建立基带时域信号</h3><p>基带信号一般为零频的宽带或窄带信号，一开始的想法是利用不同频率的正弦波时域叠加构造宽带信号，但是傅里叶变换以后的叠加信号在频域上不连续。于是我反着来，先构建连续的频谱，然后用傅里叶反变换得到时域信号。</p><p>首先创建一个长度为$N$的全0行向量,然后将带宽内的元素全部赋值为1.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spectrum = <span class="built_in">zeros</span>(<span class="number">1</span>, N);</span><br><span class="line">spectrum(f &lt;= bandwidth) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>我们得到了一个在索引值小于bandwidth时值全为1的行向量，可以认定为信号频谱。于是可以构建两个这样的不同带宽的频谱如下图:</p><p><img src="/images/%E5%AE%BD%E5%B8%A6%E4%BF%A1%E5%8F%B7.svg" alt="宽带信号"></p><p>接着为了得到时域信号我们对其做傅里叶反变换，然后再做傅里叶变换得到时域信号的频谱(觉得麻烦这步可以省略):</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal = ifft(spectrum);</span><br><span class="line">signal_fft  = fft(signal);</span><br></pre></td></tr></table></figure><p>做傅里叶变换后，在高频会出现镜像，我们舍弃掉高频的部分的数据只讨论基带信号本身。<br>然后将代码简单假工一下做成函数方便一会调用。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">broadband</span><span class="params">(varargin)</span></span></span><br><span class="line">    p = inputParser;            <span class="comment">% 函数的输入解析器</span></span><br><span class="line">    p.addParameter(<span class="string">&#x27;fs&#x27;</span>,<span class="number">1000</span>);  <span class="comment">% 设置变量名和默认参数</span></span><br><span class="line">    p.addParameter(<span class="string">&#x27;T&#x27;</span>,<span class="number">1</span>);      <span class="comment">% 设置变量名和默认参数</span></span><br><span class="line">    p.addParameter(<span class="string">&#x27;bandwidth&#x27;</span>,<span class="number">50</span>);      <span class="comment">% 设置变量名和默认参数</span></span><br><span class="line">    p.parse(varargin&#123;:&#125;);       <span class="comment">% 对输入变量进行解析，如果检测到前面的变量被赋值，则更新变量取值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 生成频谱</span></span><br><span class="line">    N = p.Results.fs*p.Results.T; <span class="comment">% 信号长度</span></span><br><span class="line">    f = <span class="built_in">linspace</span>(<span class="number">0</span>, p.Results.fs, N); <span class="comment">% 频率范围</span></span><br><span class="line">    spectrum = <span class="built_in">zeros</span>(<span class="number">1</span>, N);</span><br><span class="line">    spectrum(f &lt;= p.Results.bandwidth) = <span class="number">1</span>; <span class="comment">% 在带宽内设置频谱幅度为1</span></span><br><span class="line">    <span class="comment">% 生成时域信号</span></span><br><span class="line">    signal = ifft(spectrum);</span><br><span class="line">    <span class="comment">%傅里叶变换</span></span><br><span class="line">    signal_fft  = fft(signal);</span><br><span class="line"></span><br><span class="line">    y.fft = signal_fft(<span class="number">1</span>:<span class="keyword">end</span>/<span class="number">2</span>);</span><br><span class="line">    y.f=f(<span class="number">1</span>:<span class="keyword">end</span>/<span class="number">2</span>);</span><br><span class="line">    y.<span class="built_in">real</span> = signal;</span><br><span class="line">    y.t=<span class="built_in">linspace</span>(<span class="number">0</span>, p.Results.T, N);</span><br><span class="line">    y.n=N;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="建立载波时域信号"><a href="#建立载波时域信号" class="headerlink" title="建立载波时域信号"></a>建立载波时域信号</h3><p>直接生成特定频率的正弦波即可，注意为了一会与基带信号进行运算，要保证生成的信号长度与基带信号相同。函数代码如下</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">wave_init</span><span class="params">(varargin)</span></span></span><br><span class="line">    p = inputParser;            <span class="comment">% 函数的输入解析器</span></span><br><span class="line">    p.addParameter(<span class="string">&#x27;fs&#x27;</span>,<span class="number">1000</span>);  <span class="comment">% 设置变量名和默认参数</span></span><br><span class="line">    p.addParameter(<span class="string">&#x27;L&#x27;</span>,<span class="number">1000</span>);      <span class="comment">% 设置变量名和默认参数</span></span><br><span class="line">    p.addParameter(<span class="string">&#x27;a1&#x27;</span>,<span class="number">0</span>);      <span class="comment">% 设置变量名和默认参数</span></span><br><span class="line">    p.addParameter(<span class="string">&#x27;f1&#x27;</span>,<span class="number">0</span>);      <span class="comment">% 设置变量名和默认参数</span></span><br><span class="line">    p.parse(varargin&#123;:&#125;);       <span class="comment">% 对输入变量进行解析，如果检测到前面的变量被赋值，则更新变量取值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 定义参数</span></span><br><span class="line">    T = <span class="number">1</span>/p.Results.fs;               <span class="comment">% 采样间隔</span></span><br><span class="line">    t = (<span class="number">0</span>:p.Results.L<span class="number">-1</span>)*T;          <span class="comment">% 时间向量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 生成正弦波信号</span></span><br><span class="line">    reslut = p.Results.a1*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*p.Results.f1*t);</span><br><span class="line">    temp_fft=<span class="built_in">abs</span>(fft(reslut)); </span><br><span class="line">    f = <span class="built_in">linspace</span>(<span class="number">0</span>, p.Results.fs, p.Results.L); <span class="comment">% 频率范围</span></span><br><span class="line"></span><br><span class="line">    y.fft = temp_fft(<span class="number">1</span>:<span class="keyword">end</span>/<span class="number">2</span>);</span><br><span class="line">    y.f = f(<span class="number">1</span>:<span class="keyword">end</span>/<span class="number">2</span>);</span><br><span class="line">    y.<span class="built_in">real</span> = reslut;</span><br><span class="line">    y.t = t;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>值得注意，这里是直接使用正弦信号进行快速傅里叶变换，傅里叶变换会将信号从时域转换到频域，得到频谱。频谱是一个复数，包含幅度和相位信息。取绝对值操作后，我们得到了频谱的幅度，这表示了在不同频率下信号的能量分布情况，当然也可以直接对信号进行平方运算，我们就可以的得到信号在频域上的能量分布情况，对信号的功率谱密度进行分析。利用以上函数构造两个频率为100Hz和130Hz的载波信号。</p><p><img src="/images/%E8%BD%BD%E6%B3%A2.svg" alt="载波"></p><h3 id="频谱搬移"><a href="#频谱搬移" class="headerlink" title="频谱搬移"></a>频谱搬移</h3><p>根据前文的计算，想要实现频谱搬移需要将基带信号与载波信号相乘。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 宽带信号</span></span><br><span class="line">wave_0 = broadband(<span class="string">&#x27;fs&#x27;</span>,<span class="number">1000</span>,<span class="string">&#x27;T&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;bandwidth&#x27;</span>,<span class="number">30</span>);</span><br><span class="line">wave_1 = broadband(<span class="string">&#x27;fs&#x27;</span>,<span class="number">1000</span>,<span class="string">&#x27;T&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;bandwidth&#x27;</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%载波信号</span></span><br><span class="line">c_wave = wave_init(<span class="string">&#x27;a1&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;f1&#x27;</span>,<span class="number">100</span>);</span><br><span class="line">c_wave_1 = wave_init(<span class="string">&#x27;a1&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;f1&#x27;</span>,<span class="number">130</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 搬移</span></span><br><span class="line">s_wave = c_wave.<span class="built_in">real</span>.*wave_0.<span class="built_in">real</span>;</span><br><span class="line">s_wave_fft = <span class="built_in">abs</span>(fft(s_wave));</span><br><span class="line"></span><br><span class="line">s_wave_1 = c_wave_1.<span class="built_in">real</span>.*wave_1.<span class="built_in">real</span>;</span><br><span class="line">s_wave_fft_1 = <span class="built_in">abs</span>(fft(s_wave_1));</span><br></pre></td></tr></table></figure><p>这是搬移后的频谱</p><p><img src="/images/%E8%B0%83%E5%88%B6%E6%B3%A2.svg" alt="调制波"></p><p>随后我们再将调制波时域上相加，即可得到一个宽带信号。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wave = s_wave + s_wave_1;</span><br><span class="line">wave_fft = <span class="built_in">abs</span>(fft(wave));</span><br></pre></td></tr></table></figure><p>如图:</p><p><img src="/images/%E5%8F%A0%E5%8A%A0.svg" alt="叠加"></p><p>若不进行搬移直接叠加会发生干扰，信号无法解调，如图:<a id="频谱叠加"></a></p><p><img src="/images/%E7%AE%80%E5%8D%95%E5%8F%A0%E5%8A%A0.svg" alt="简单叠加"></p><p>这是主函数调试代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 宽带信号</span></span><br><span class="line">wave_0 = broadband(<span class="string">&#x27;fs&#x27;</span>,<span class="number">1000</span>,<span class="string">&#x27;T&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;bandwidth&#x27;</span>,<span class="number">30</span>);</span><br><span class="line">wave_1 = broadband(<span class="string">&#x27;fs&#x27;</span>,<span class="number">1000</span>,<span class="string">&#x27;T&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;bandwidth&#x27;</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%载波信号</span></span><br><span class="line">c_wave = wave_init(<span class="string">&#x27;a1&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;f1&#x27;</span>,<span class="number">100</span>);</span><br><span class="line">c_wave_1 = wave_init(<span class="string">&#x27;a1&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;f1&#x27;</span>,<span class="number">130</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 搬移</span></span><br><span class="line">s_wave = c_wave.<span class="built_in">real</span>.*wave_0.<span class="built_in">real</span>;</span><br><span class="line">s_wave_fft = <span class="built_in">abs</span>(fft(s_wave));</span><br><span class="line"></span><br><span class="line">s_wave_1 = c_wave_1.<span class="built_in">real</span>.*wave_1.<span class="built_in">real</span>;</span><br><span class="line">s_wave_fft_1 = <span class="built_in">abs</span>(fft(s_wave_1));</span><br><span class="line"></span><br><span class="line">wave = s_wave + s_wave_1;</span><br><span class="line">wave_fft = <span class="built_in">abs</span>(fft(wave));</span><br><span class="line"></span><br><span class="line"><span class="comment">% s_wave_2 = wave_0.real + wave_1.real;</span></span><br><span class="line"><span class="comment">% s_wave_2_fft = abs(fft(s_wave_2));</span></span><br><span class="line"><span class="comment">% subplot(1,1,1);</span></span><br><span class="line"><span class="comment">% plot(wave_0.f, s_wave_2_fft(1:end/2));</span></span><br><span class="line"><span class="comment">% title(&quot;叠加频谱&quot;);</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(wave_0.f, wave_0.fft);</span><br><span class="line">title(<span class="string">&quot;信号α频谱&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">% subplot(2,1,2);</span></span><br><span class="line"><span class="built_in">plot</span>(wave_1.f, wave_1.fft);</span><br><span class="line">title(<span class="string">&quot;信号β频谱&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(c_wave.f, c_wave.fft);</span><br><span class="line">title(<span class="string">&quot;载波频谱i&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">plot</span>(c_wave.f, c_wave_1.fft);</span><br><span class="line">title(<span class="string">&quot;载波频谱ii&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">plot</span>(c_wave.f, s_wave_fft(<span class="number">1</span>:<span class="keyword">end</span>/<span class="number">2</span>));</span><br><span class="line">title(<span class="string">&quot;调制波(α*i)频谱&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">plot</span>(c_wave.f, s_wave_fft_1(<span class="number">1</span>:<span class="keyword">end</span>/<span class="number">2</span>));</span><br><span class="line">title(<span class="string">&quot;调制波(β*ii)频谱&quot;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">7</span>,<span class="number">1</span>,<span class="number">7</span>);</span><br><span class="line"><span class="built_in">plot</span>(c_wave.f, wave_fft(<span class="number">1</span>:<span class="keyword">end</span>/<span class="number">2</span>));</span><br><span class="line">title(<span class="string">&quot;调制波叠加((α*i)+(β*ii))频谱&quot;</span>);</span><br></pre></td></tr></table></figure><p>整体对比图</p><p><img src="/images/%E5%85%A8%E5%9B%BE.svg" alt="全图"></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ViVado报错记录及解决方式</title>
      <link href="//article/Vivado_Log_Resolution.html"/>
      <url>//article/Vivado_Log_Resolution.html</url>
      
        <content type="html"><![CDATA[<h2 id="Generate-Bitstream-Failed"><a href="#Generate-Bitstream-Failed" class="headerlink" title="Generate Bitstream Failed"></a><center>Generate Bitstream Failed</center></h2><h3 id="DRC-NSTD-1"><a href="#DRC-NSTD-1" class="headerlink" title="[DRC NSTD-1]"></a>[DRC NSTD-1]</h3><ul><li><p><strong>问题</strong><br>引脚定义了，没有使用或者没做物理约束导致生成bit文件报错，DRC电气检测失败。此处特指顶层文件输入输出引脚。</p></li><li><p><strong>解决</strong></p><p>  1.找到未使用引脚并注释。</p><p>  2.使用TCL文件忽略该项报错,TCL文件内容如下，手动创建该文件后，在Vivado右栏选择Setting-&gt;Project Settings-&gt;Implementation-&gt;Write Bitstream-&gt;tcl.pre选择该文件并导入后重新执行Generate Bitstream。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_property SEVERITY &#123;Warning&#125; [get_drc_checks NSTD<span class="number">-1</span>]</span><br><span class="line">set_property SEVERITY &#123;Warning&#125; [get_drc_checks UCIO<span class="number">-1</span>]</span><br><span class="line">set_property SEVERITY &#123;Warning&#125; [get_drc_checks RTSTAT<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="Run-Implementation-Failed"><a href="#Run-Implementation-Failed" class="headerlink" title="Run Implementation Failed"></a><center>Run Implementation Failed</center></h2><h3 id="DRC-UTLZ-1"><a href="#DRC-UTLZ-1" class="headerlink" title="[DRC UTLZ-1]"></a>[DRC UTLZ-1]</h3><blockquote><p>Resource utilization: DSP48E1 over-utilized in Top Level Design (This design requires more DSP48E1 cells than are available in the target device. This design requires 1211 of such cell types but only 900 compatible sites are available in the target device. Please analyze your synthesis results and constraints to ensure the design is mapped to Xilinx primitives as expected. If so, please consider targeting a larger device.)</p></blockquote><ul><li><p><strong>问题</strong><br>提示很明显指出,DSP资源不足.</p></li><li><p><strong>解决</strong><br>点击 Open Synthesized Design -&gt; Report Utilization 查看各个模块DSP使用情况,优化DSP使用.一般需要关注DDS,FIR,CFR等模块.</p></li></ul><hr><h2 id="Run-Synthesis-Failed"><a href="#Run-Synthesis-Failed" class="headerlink" title="Run Synthesis Failed"></a><center>Run Synthesis Failed</center></h2><h3 id="Synth-8-5535"><a href="#Synth-8-5535" class="headerlink" title="[Synth 8-5535]"></a>[Synth 8-5535]</h3><blockquote><p>port <sys_clk> has illegal connections. It is illegal to have a port connected to an input buffer and other components. The following are the port connections : Input Buffer: Port I of instance clkin1_ibufg(IBUF) in module <clk_wiz_0_clk_wiz> Other Components: Port C of instance sys_rst_n_reg(FD) in module ddr3_rw_top</p></blockquote><ul><li><p><strong>问题</strong><br>顶层时钟引脚未经过IBUF直接使用会导致此错误</p></li><li><p><strong>解决</strong><br>  使用<code>IBUF</code>和<code>BUFG</code>原语将时钟导入输入时钟缓冲和全局时钟缓冲后使用。<code>IBUFG</code>即输入全局缓冲，是与专用全局时钟输入管脚相连接的首级全局缓冲。所有从全局时钟管脚输入的信号必须经过IBUF元，否则在布局布线时会报错。 IBUFG支持AGP、CTT、GTL、GTLP、HSTL、LVCMOS、LVDCI、LVDS、LVPECL、LVTTL、PCI、PCIX和 SSTL等多种格式的IO标准。<code>BUFG</code><br>  是全局缓冲，它的输入是IBUFG的输出，BUFG的输出到达FPGA内部的IOB、CLB、选择性块RAM的时钟延迟和抖动最小。</p></li></ul><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a><center>Others</center></h2><h3 id="USF-XSim-62"><a href="#USF-XSim-62" class="headerlink" title="[USF-XSim-62]"></a>[USF-XSim-62]</h3><blockquote><p>‘compile’ step failed with error(s). Please check the Tcl console output or ‘&#x2F;xxxx&#x2F;xxx&#x2F;xxxx&#x2F;xxxxxx.sim&#x2F;sim_1&#x2F;behav&#x2F;xsim&#x2F;xvlog.log’ file for more information.</p></blockquote><ul><li><strong>问题</strong><br>行为仿真出现错误,大概率是语法错误，打开提示中指定的<code>xvlog.log</code>文件或查看Tcl控制台即可查看错误。</li><li><strong>解决</strong><br>根据<code>xvlog.log</code>详细提示解决问题。若已经解决且编译通过还显示此提示，选择此条提示-&gt;右键-&gt;Discard User Created Messages然后重新编译即可。</li></ul><h3 id="Unable-to-open-file-because-the-path-is-invalid"><a href="#Unable-to-open-file-because-the-path-is-invalid" class="headerlink" title="Unable to open file &lt;file&gt; because the path is invalid"></a>Unable to open file &lt;file&gt; because the path is invalid</h3><ul><li><strong>问题</strong><br>突然发现文件无法打开，但使用Vscode可以在路径下找到文件，且使用Vivado GUI可以打开文件。该文件存在，但无法通过Messages栏打开。</li><li><strong>解决</strong><br>打开..&#x2F;projectName.runs&#x2F;synth_1&#x2F;runme.log文件，这个是编译日志，Message栏的信息就是由这个文件生成。观察日志，发现项目名称中出现了纯数字，猜测Vivado无法识别纯数字路径。修改掉路径，重新编译，该错误解决。</li></ul>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
          <category> Vivado </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS</title>
      <link href="//article/FreeRTOS.html"/>
      <url>//article/FreeRTOS.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>FreeRTOS学习日志,由于工作原因,目前这棵技能树不作为主要发展方向了,该类型博客无限期停更…</p></blockquote><span id="more"></span><h2 id="1-关于-osThreadNew"><a href="#1-关于-osThreadNew" class="headerlink" title="1.关于 osThreadNew ()"></a>1.关于 osThreadNew ()</h2><h3 id="1-1-FreeRTOS线程与任务的关系"><a href="#1-1-FreeRTOS线程与任务的关系" class="headerlink" title="1.1 FreeRTOS线程与任务的关系"></a>1.1 FreeRTOS线程与任务的关系</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">osThreadId_t <span class="title function_">osThreadNew</span> <span class="params">(osThreadFunc_t func, </span></span><br><span class="line"><span class="params">  <span class="type">void</span> *argument, </span></span><br><span class="line"><span class="params">  <span class="type">const</span> osThreadAttr_t *attr)</span></span><br><span class="line"><span class="comment">/*******************************没有感情的分界线********************/</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">(TaskFunction_t pxTaskCode,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,</span></span><br><span class="line"><span class="params"><span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth,</span></span><br><span class="line"><span class="params"><span class="type">void</span> * <span class="type">const</span> pvParameters,</span></span><br><span class="line"><span class="params">UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span></span><br><span class="line">TaskHandle_t <span class="title function_">xTaskCreateStatic</span><span class="params">(TaskFunction_t pxTaskCode,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,</span></span><br><span class="line"><span class="params"><span class="type">void</span> * <span class="type">const</span> pvParameters,</span></span><br><span class="line"><span class="params">UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">StackType_t * <span class="type">const</span> puxStackBuffer,</span></span><br><span class="line"><span class="params">StaticTask_t * <span class="type">const</span> pxTaskBuffer )</span></span><br></pre></td></tr></table></figure><p>先后分别是CMSIS-OS和FreeRTOS提供的任务创建API，函数名给我带来了一个疑问<strong>线程和任务之间的关系</strong>，翻阅资料后找到如下解释。</p><blockquote><p>在多数通用（分时）操作系统（如Linux，Windows）中，进程是系统资源分配的最小单位，线程为CPU调度的最小单元。而在实时操作系统中，多数情况下不区分线程与进程进行独立管理，为了减小系统资源占用以及提高实时性，往往将线程与进程合二为一，采用任务（一个个独立且无法返回的函数）作为应用程序的最小调度运行单元，使用TCB（任务控制块）对任务进行管理，FreeRTOS即是如此。<br>    结论：像FreeRTOS这样的轻量级OS，其中的任务与线程的含义一致，即在FreeRTOS上跑的整个程序即为一个进程，该进程中又包含着多个线程（任务），这些线程有些是系统自动创建的，有些为用户手动创建。<br>                                                    <a href="https://blog.csdn.net/weixin_48206270/article/details/124102544">原文链接</a></p></blockquote><p><strong>翻阅ST提供的用户手册得到如下信息。</strong></p><blockquote><p>本用户手册的目标读者为在 STM32 微控制器上使用 STM32Cube 固件的开发者。它完整描述了如何使用具有实时操作系统 （RTOS）的 STM32Cube 固件组件；本用户手册还提供了一组示例说明，它们基于 FreeRTOS，使用 CMSIS-OS 封装层提供的通用 API。<br> 在 STM32Cube 固件中，通过 ARM 提供的通用 CMSIS-OS 封装层，FreeRTOS 用作实时操作系统。使用 FreeRTOS 的样例和应用可直接移植到其它任何 RTOS 而不需要修改高层API，在此情况下仅需更改 CMSIS-OS 封装。</p></blockquote><ul><li>   <strong>结论:osThreadNew()是ARM的CMSIS-OS的封装层API，内部包含了FreeRTOS的<br>   动态任务创建xTaskCreate()<br>   静态任务创建xTaskCreateStatic()<br>   根据参数选择选择调用动态还是静态创建，具体实现后文给出。</strong></li></ul><h3 id="1-2-osThreadNew"><a href="#1-2-osThreadNew" class="headerlink" title="1.2 osThreadNew ()"></a>1.2 osThreadNew ()</h3><h4 id="1-2-1-osThreadNew-如何实现动态创建与静态创建的选择"><a href="#1-2-1-osThreadNew-如何实现动态创建与静态创建的选择" class="headerlink" title="1.2.1 osThreadNew ()如何实现动态创建与静态创建的选择"></a>1.2.1 osThreadNew ()如何实现动态创建与静态创建的选择</h4><p>从前文已知osThreadNew()是ARM提供的上层封装，那么具体是如何实现动态与静态的选择。<br>翻阅源码发现原理在于其参数的选择，一下给出源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">osThreadId_t <span class="title function_">osThreadNew</span> <span class="params">(osThreadFunc_t func, <span class="type">void</span> *argument, <span class="type">const</span> osThreadAttr_t *attr)</span> &#123;</span><br><span class="line">  <span class="type">char</span> empty;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">uint32_t</span> <span class="built_in">stack</span>;</span><br><span class="line">  TaskHandle_t hTask;</span><br><span class="line">  UBaseType_t prio;</span><br><span class="line">  <span class="type">int32_t</span> mem;</span><br><span class="line"></span><br><span class="line">  hTask = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!IS_IRQ() &amp;&amp; (func != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="built_in">stack</span> = configMINIMAL_STACK_SIZE;</span><br><span class="line">    prio  = (UBaseType_t)osPriorityNormal;</span><br><span class="line"></span><br><span class="line">    empty = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    name  = &amp;empty;</span><br><span class="line">    mem   = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (attr-&gt;name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        name = attr-&gt;name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (attr-&gt;priority != osPriorityNone) &#123;</span><br><span class="line">        prio = (UBaseType_t)attr-&gt;priority;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((prio &lt; osPriorityIdle) || (prio &gt; osPriorityISR) || ((attr-&gt;attr_bits &amp; osThreadJoinable) == osThreadJoinable)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (attr-&gt;stack_size &gt; <span class="number">0U</span>) &#123;</span><br><span class="line">        <span class="comment">/* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */</span></span><br><span class="line">        <span class="comment">/* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */</span></span><br><span class="line">        <span class="built_in">stack</span> = attr-&gt;stack_size / <span class="keyword">sizeof</span>(StackType_t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((attr-&gt;cb_mem    != <span class="literal">NULL</span>) &amp;&amp; (attr-&gt;cb_size    &gt;= <span class="keyword">sizeof</span>(StaticTask_t)) &amp;&amp;</span><br><span class="line">          (attr-&gt;stack_mem != <span class="literal">NULL</span>) &amp;&amp; (attr-&gt;stack_size &gt;  <span class="number">0U</span>)) &#123;</span><br><span class="line">        mem = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((attr-&gt;cb_mem == <span class="literal">NULL</span>) &amp;&amp; (attr-&gt;cb_size == <span class="number">0U</span>) &amp;&amp; (attr-&gt;stack_mem == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">          mem = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      mem = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">1</span>) &#123;</span><br><span class="line">      hTask = xTaskCreateStatic ((TaskFunction_t)func, name, <span class="built_in">stack</span>, argument, prio, (StackType_t  *)attr-&gt;stack_mem,</span><br><span class="line">                                                                                    (StaticTask_t *)attr-&gt;cb_mem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xTaskCreate ((TaskFunction_t)func, name, (<span class="type">uint16_t</span>)<span class="built_in">stack</span>, argument, prio, &amp;hTask) != pdPASS) &#123;</span><br><span class="line">          hTask = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((osThreadId_t)hTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在末尾可以看出使用哪一种创建方式由参数<code>mem</code>决定，阅读前文发现只有</p><ul><li>当<code>attr-&gt;stack_mem</code>有值且指定用户数组以及任务控制块地址时的时候会使得<code>mem</code>置1，此时调用的时静态创建任务函数。</li><li>当<code>attr-&gt;stack_mem</code>没有值的时候会使得<code>mem</code>置0，此时调用的时动态创建任务函数。</li></ul></li><li><p>而<code>attr-&gt;stack_mem</code>的值是由<code>const osThreadAttr_t *attr</code>形参结构体中取得，在创建任务的时候需要定义一个结构体作为参数传入osThreadNew()中，CubeMX给出的默认任务参数如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">osThreadId_t startTaskHandle;</span><br><span class="line"><span class="type">const</span> osThreadAttr_t startTask_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;startTask&quot;</span>,</span><br><span class="line">  .stack_size = <span class="number">128</span> * <span class="number">4</span>,  <span class="comment">//0.5KB</span></span><br><span class="line">  .priority = (osPriority_t) osPriorityLow3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>必须同时给出任务栈大小，任务堆栈，任务控制块地址才能调用静态创建任务函数，否则只取<code>attr-&gt;stack_mem</code>的值作为任务栈大小动态创建任务。若连<code>attr-&gt;stack_mem</code>都未给出，则取系统默认设置为任务栈大小动态创建任务。</p></li></ul><h4 id="1-2-2-xTaskCreate-任务栈空间理解"><a href="#1-2-2-xTaskCreate-任务栈空间理解" class="headerlink" title="1.2.2 xTaskCreate()任务栈空间理解"></a>1.2.2 xTaskCreate()任务栈空间理解</h4><p>在阅读动态创建函数传参时候发现，居然也有任务栈空间这一项参数，而我记得我阅读操作手册的时候写的是动态任务创建任务栈空间由操作系统分配，归操作系统管理，那么为什么还要传这一个参数呢。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xTaskCreate ((TaskFunction_t)func, name, (<span class="type">uint16_t</span>)<span class="built_in">stack</span>, argument, prio, &amp;hTask) </span><br></pre></td></tr></table></figure><p>回去重新阅读了操作手册发现自己理解错误，以下贴出操作手册原文。</p><blockquote><p>每个任务都需要 RAM 来保存任务状态，并由任务用作其堆栈。 如果使用 xTaskCreate() 创建任务，则所需的 RAM 将自动 从 FreeRTOS 堆中分配。 如果创建任务 使用了 xTaskCreateStatic()，则 RAM 由应用程序编写者提供，因此可以在编译时进行静态分配。</p></blockquote><ul><li>在<strong>动态创建</strong>任务时也是<strong>需要指定任务栈空间</strong>的，但此时任务栈空间是由操作系统从<strong>自己管理的堆</strong>中分配的，管理权归操作系统。</li><li>在<strong>静态创建</strong>任务时候，指定的任务栈空间是由用户自己提供的，而占用的空间是在RAM中除去RTOS所管理的堆剩下的空间中提供的，所以不由RTOS管理。</li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00125.html">这里给出FreeRTOS官网开发者手册关于xTaskCreate描述的地址</a></li><li><a href="https://www.freertos.org/zh-cn-cmn-s/Static_Vs_Dynamic_Memory_Allocation.html">这里给出FreeRTOS官网开发者手册关于静态与动态创建任务描述的地址</a></li></ul><p><strong>所以实际上动态创建任务也是需要指定任务栈空间的，但是我们创建时并没有给出参数，他又是传了什么进去呢？</strong></p><p>阅读上文源码发现，该参数一开始就被赋值了<br><code>stack = configMINIMAL_STACK_SIZE</code><br>其中<br><code>configMINIMAL_STACK_SIZE</code><br>是个宏定义，我们在<em>FreeRTOSConfig.h</em>文件中找到了定义<br><code>#define configMINIMAL_STACK_SIZE                 ((uint16_t)128)</code></p><ul><li>也就是说当我们不指定任务栈空间，CMSIS-OS提供的封装帮我自动设置了任务栈空间，并且调用动态创建任务函数。</li></ul><h4 id="1-2-3-CMSIS-OS与FreeRTOS任务栈空间单位不同！"><a href="#1-2-3-CMSIS-OS与FreeRTOS任务栈空间单位不同！" class="headerlink" title="1.2.3 CMSIS-OS与FreeRTOS任务栈空间单位不同！"></a>1.2.3 CMSIS-OS与FreeRTOS任务栈空间单位不同！</h4><p>接下来我遇到了最坑的一个点，如题所说，CMSIS-OS与FreeRTOS任务栈空间单位不同。</p><ul><li>在学习FreeRTOS时我观看了<em>正点原子</em>的视频，包括在网上搜索的资料都是面向FreeRTOS的。而FreeRTOS提供的创建任务函数中指定任务栈大小的参数<code>stack</code>其单位是<strong>字</strong>。<blockquote><p>在stm32中，1字&#x3D;4字节     1字节&#x3D;8位</p></blockquote></li></ul><p>所以，我理所当然（我大意了）的认为<code>osThreadNew()</code>参数中的<code>stack_size </code>其单位也是字，所以在计算的时候一直当作字来计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> osThreadAttr_t startTask_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;startTask&quot;</span>,</span><br><span class="line">  .stack_size = <span class="number">128</span> * <span class="number">4</span>,</span><br><span class="line">  .priority = (osPriority_t) osPriorityLow3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并且，在这个函数中的注释写了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */</span></span><br><span class="line"><span class="comment">/* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */</span></span><br><span class="line">翻译过来就是</span><br><span class="line"><span class="comment">/*在FreeRTOS中，堆栈不是以字节为单位，而是以sizeof（StackType_t）为单位，在ARM端口上为4*/</span></span><br><span class="line"><span class="comment">/*因此，堆栈大小应为4字节对齐，以避免除法造成的副作用*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 但当我调试时候计算栈空间时发现不太对劲，具体怎么发现的我就不说了，反正不是很聪明的样子。贴个调试图。<br> <img src="https://img-blog.csdnimg.cn/f29e34a84c094b03842a3e6e19082770.png" alt="在这里插入图片描述"><br>在和老学长一番争论，并且重新翻阅源码以及用户手册后我突然发现在注释的前后写了一段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (attr-&gt;stack_size &gt; <span class="number">0U</span>) &#123;</span><br><span class="line">  <span class="comment">/* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */</span></span><br><span class="line">  <span class="comment">/* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */</span></span><br><span class="line">  <span class="built_in">stack</span> = attr-&gt;stack_size / <span class="keyword">sizeof</span>(StackType_t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他把我传进去的参数除了一个<code>StackType_t</code>大小。<br>查阅其定义发现<br><code>typedef portSTACK_TYPE StackType_t;</code><br><code>#define portSTACK_TYPEuint32_t</code></p><blockquote><p>这个类型大小32位，8位1字节，也就4个字节，1个字。<br><code>sizeof()</code>用于返回运算对象的内存大小，单位是字节。<br>所以<code>sizeof(StackType_t)=4</code></p></blockquote><ul><li>也就是说在<code>osThreadNew()</code>的任务栈空间参数在经过ARM封装后实际上是以“字节”为单位的，所以也就是说我我传进来的数字实际上是 <code>128 * 4=512字节/4=128字</code>赋给了<code>stack </code>。</li></ul><p>这里贴出官网对参数<code>usStackDepth  </code>也就是<code>stack </code>赋给的形参值的介绍与地址。<a href="https://www.freertos.org/zh-cn-cmn-s/a00125.html">用户手册参数介绍地址</a></p><blockquote><p>要分配用于 任务堆栈的 字数（不是字节）。例如，如果堆栈的宽度为 16 位，usStackDepth 为 100，则将分配 200 字节用作该任务的堆栈。 再举一例，如果堆栈的宽度为 32 位，usStackDepth 为 400，则将分配 1600 字节用作该任务的堆栈。<br>堆栈深度与堆栈宽度的乘积不得超过 size_t 类型变量所能包含的最大值。</p></blockquote><h4 id="1-2-4-选择动态分配时osThreadNew-分配的任务栈空间"><a href="#1-2-4-选择动态分配时osThreadNew-分配的任务栈空间" class="headerlink" title="1.2.4 选择动态分配时osThreadNew()分配的任务栈空间"></a>1.2.4 选择动态分配时osThreadNew()分配的任务栈空间</h4><p>这个比较好找，直接阅读源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">osThreadId_t <span class="title function_">osThreadNew</span> <span class="params">(osThreadFunc_t func, <span class="type">void</span> *argument, <span class="type">const</span> osThreadAttr_t *attr)</span> &#123;</span><br><span class="line">  <span class="type">char</span> empty;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">uint32_t</span> <span class="built_in">stack</span>;</span><br><span class="line">  TaskHandle_t hTask;</span><br><span class="line">  UBaseType_t prio;</span><br><span class="line">  <span class="type">int32_t</span> mem;</span><br><span class="line"></span><br><span class="line">  hTask = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!IS_IRQ() &amp;&amp; (func != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="built_in">stack</span> = configMINIMAL_STACK_SIZE;</span><br><span class="line">    prio  = (UBaseType_t)osPriorityNormal;</span><br><span class="line"></span><br><span class="line">    empty = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    name  = &amp;empty;</span><br><span class="line">    mem   = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (attr-&gt;name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        name = attr-&gt;name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (attr-&gt;priority != osPriorityNone) &#123;</span><br><span class="line">        prio = (UBaseType_t)attr-&gt;priority;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((prio &lt; osPriorityIdle) || (prio &gt; osPriorityISR) || ((attr-&gt;attr_bits &amp; osThreadJoinable) == osThreadJoinable)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (attr-&gt;stack_size &gt; <span class="number">0U</span>) &#123;</span><br><span class="line">        <span class="comment">/* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */</span></span><br><span class="line">        <span class="comment">/* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */</span></span><br><span class="line">        <span class="built_in">stack</span> = attr-&gt;stack_size / <span class="keyword">sizeof</span>(StackType_t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((attr-&gt;cb_mem    != <span class="literal">NULL</span>) &amp;&amp; (attr-&gt;cb_size    &gt;= <span class="keyword">sizeof</span>(StaticTask_t)) &amp;&amp;</span><br><span class="line">          (attr-&gt;stack_mem != <span class="literal">NULL</span>) &amp;&amp; (attr-&gt;stack_size &gt;  <span class="number">0U</span>)) &#123;</span><br><span class="line">        mem = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((attr-&gt;cb_mem == <span class="literal">NULL</span>) &amp;&amp; (attr-&gt;cb_size == <span class="number">0U</span>) &amp;&amp; (attr-&gt;stack_mem == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">          mem = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      mem = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">1</span>) &#123;</span><br><span class="line">      hTask = xTaskCreateStatic ((TaskFunction_t)func, name, <span class="built_in">stack</span>, argument, prio, (StackType_t  *)attr-&gt;stack_mem,</span><br><span class="line">                                                                                    (StaticTask_t *)attr-&gt;cb_mem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xTaskCreate ((TaskFunction_t)func, name, (<span class="type">uint16_t</span>)<span class="built_in">stack</span>, argument, prio, &amp;hTask) != pdPASS) &#123;</span><br><span class="line">          hTask = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((osThreadId_t)hTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数开头<code>    stack = configMINIMAL_STACK_SIZE;</code></p><p>参数<code>stack</code>在<code>osThreadNew()</code>函数一开始就被赋值了，若参数<code>attr-&gt;stack_mem</code>缺省，则<code>stack</code>值不会被改变。翻找<code>configMINIMAL_STACK_SIZE</code>定义。<br><code>#define configMINIMAL_STACK_SIZE                 ((uint16_t)128)</code></p><ul><li>也就是说当用户不指定任务栈空间，CMSIS-OS会自动给用户分配128<strong>字</strong>的任务栈。而只有<code>attr-&gt;stack_size </code>的值大于0的时候，才会被除4。</li><li>所以此时的128是以<strong>字</strong>为单位的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (attr-&gt;stack_size &gt; <span class="number">0U</span>) &#123;</span><br><span class="line">  <span class="comment">/* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */</span></span><br><span class="line">  <span class="comment">/* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */</span></span><br><span class="line">  <span class="built_in">stack</span> = attr-&gt;stack_size / <span class="keyword">sizeof</span>(StackType_t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>结论:1.使用静态任务创建需要用户自己指定内存空间大小，参数单位是“字节”，并调用xTaskCreateStatic()。2.使用动态任务创建CMSIS-OS指定了任务栈大小128字，并调用xTaskCreate()。3.用户可以根据需要修改configMINIMAL_STACK_SIZE宏定义的值，来修改attr-&gt;stack_size缺省时任务栈大小的默认值。</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>本站数学方程式渲染模板</title>
      <link href="//article/Mathematical.html"/>
      <url>//article/Mathematical.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇文章仅用作记录满足MathJax渲染条件的数学方程模板…</p></blockquote><span id="more"></span><h2 id="简单方程"><a href="#简单方程" class="headerlink" title="简单方程"></a>简单方程</h2><p>对于简单的方程式<br>$$\begin{equation} \label{eq1}<br>e&#x3D;mc^2<br>\end{equation}$$<br>请使用以下形式给出一个标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;equation&#125; \label&#123;eq1&#125;</span><br><span class="line">e=mc^2</span><br><span class="line">\end&#123;equation&#125;$$</span><br></pre></td></tr></table></figure><p>然后，您可以使用以下内容轻松地在文本中引用此等式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The famous matter-energy equation $\eqref&#123;eq1&#125;$ proposed by Einstein...</span><br></pre></td></tr></table></figure><p>The famous matter-energy equation $\eqref{eq1}$ proposed by Einstein…</p><h2 id="从编号中排除方程式"><a href="#从编号中排除方程式" class="headerlink" title="从编号中排除方程式"></a>从编号中排除方程式</h2><p>在环境中，如果您不想对一个或某些方程进行编号，只需在这些方程后面使用即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;align&#125;</span><br><span class="line">-4 + 5x &amp;= 2 + y \nonumber \\</span><br><span class="line">w + 2 &amp;= -1 + w \\</span><br><span class="line">ab &amp;= cb</span><br><span class="line">\end&#123;align&#125;$$</span><br></pre></td></tr></table></figure><h2 id="使用指定标签标记方程"><a href="#使用指定标签标记方程" class="headerlink" title="使用指定标签标记方程"></a>使用指定标签标记方程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$x+1\over\sqrt&#123;1-x^2&#125; \tag&#123;i&#125;\label&#123;eq_tag&#125;$$</span><br></pre></td></tr></table></figure><p>$$x+1\over\sqrt{1-x^2} \tag{i}\label{eq_tag}$$<br>Equation $\eqref{eq_tag}$ use <code>\tag&#123;&#125;</code> instead of automatic numbering.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于version `GLIBC_2.34&#39; not found解决办法</title>
      <link href="//article/solution_for_version_GLIBC_2_34_not_found.html"/>
      <url>//article/solution_for_version_GLIBC_2_34_not_found.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用编译器<code>-l</code>和<code>-L</code>选项手动添加从目标系统下载的链接库从而解决gblc版本不匹配的问题。</p></blockquote><span id="more"></span><h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用arm-linux-gnueabihf-gcc交叉编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc main.c -o main</span><br></pre></td></tr></table></figure><p> 部署到开发板后运行报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debian@npi:~$ ./main </span><br><span class="line">./main: /lib/arm-linux-gnueabihf/libc.so.6: version `GLIBC_2.34<span class="string">&#x27; not found (required by ./main)</span></span><br></pre></td></tr></table></figure><h2 id="查询资料"><a href="#查询资料" class="headerlink" title="查询资料"></a>查询资料</h2><p>使用bing和百度搜索 version &#96;GLIBC_2.34’ not found 得到的解决办法归纳为一下几点</p><ul><li>升级部署环境系统版本，降低打包编译环境的系统版本</li><li><del>在部署环境中下载符合版本的gblc库（一般高于原来的环境）</del> </li><li>使用工具gblc-all-in-one文档描述是</li></ul><blockquote><p>这是一个在ubuntu环境下随意更改文件glibc版本的便捷工具</p></blockquote><ul><li><p>使用静态链接库</p><p>  方法一：可以完美解决，但是太傻了，作为开发人员总不能每次开发一个系统就换自己系统的版本吧。<br>  方法二：看运气，说不定升级了以后开发板的系统命令就用不了了，所以不建议随意升级这个库，具体原因可以<br>  自行百度。<br>  方法三：没看懂原理（刚入门）所以也没去尝试。<br>  方法四：使用静态链接库，缺点是不确定以后会不会出什么问题，而且编译后的文件体积巨大。</p></li></ul><h2 id="整理思路"><a href="#整理思路" class="headerlink" title="整理思路"></a>整理思路</h2><p>我查询了交叉编译的指令具体和GCC差不了多少其中有一<code> -l</code>和<code>-L</code> 命令。<strong>用于指定链接库的链接目录</strong>。具体用法参见<a href="http://c.biancheng.net/view/2382.html">GCC -l选项：手动添加链接库</a>，所以我想能不能在编译的的时候指定需要链接的库或目录，这样就不会需要改变双方的环境了。</p><hr><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><p>查找网络发现在编译c语言时候需要用到的库为<code>libc</code>。<br>我不使用编译器自带的而是从开发板上下载了该文件作为编译文件的链接库。<br>然后在编译的时候指定该文件作为链接目标。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yhw@yhw-virtual-machine:~/gxl$ scp laojia:/lib/libc.so.6 ./   <span class="comment"># 从开发板（服务器）系统的/lib目录下找到libc.so.6下载到当前目录</span></span><br><span class="line">yhw@yhw-virtual-machine:~/gxl$ arm-linux-gnueabihf-gcc main.c -o main ./libc.so.6 <span class="comment">#指定刚刚下载的libc.so.6文件作为编译时候链接文件</span></span><br></pre></td></tr></table></figure><p>然后将程序部署到开发板环境运行成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">debian@npi:~$ ./main <span class="comment">#运行</span></span><br><span class="line">Hello World!</span><br><span class="line">debian@npi:</span><br></pre></td></tr></table></figure><p>而后尝试用指令-L指定一个目录让编译器从其中查找链接库，这样不用一个一个的输入文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yhw@yhw-virtual-machine:~/gxl$ arm-linux-gnueabihf-gcc main.c -o main -L ./lib_dir/ <span class="comment">#自行创建文件夹并将文件移入后再执行此步骤</span></span><br></pre></td></tr></table></figure><p>编译通过，完美解决。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>使用编译器<code>-l</code>和<code>-L</code>选项手动添加从目标系统下载的链接库从而解决gblc版本不匹配的问题。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
